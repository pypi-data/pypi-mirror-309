"use strict";(self["webpackChunkdpgui"]=self["webpackChunkdpgui"]||[]).push([[257],{4703:function(e){e.exports=JSON.parse('{"object":"Argument","name":"run_jdata","type":["dict"],"optional":false,"alias":[],"doc":"param.json file","repeat":false,"sub_fields":{"type_map":{"object":"Argument","name":"type_map","type":["list"],"optional":false,"alias":[],"doc":"Atom types. Reminder: The elements in param.json, type.raw and data.lmp(when using lammps) should be in the same order.","repeat":false,"sub_fields":{},"sub_variants":{}},"mass_map":{"object":"Argument","name":"mass_map","type":["list","str"],"optional":true,"alias":[],"doc":"Standard atomic weights (default: \\"auto\\"). if one want to use isotopes, or non-standard element names, chemical symbols, or atomic number in the type_map list, please customize the mass_map list instead of using \\"auto\\".","repeat":false,"sub_fields":{},"sub_variants":{},"default":"auto"},"use_ele_temp":{"object":"Argument","name":"use_ele_temp","type":["int"],"optional":true,"alias":[],"doc":"Currently only support fp_style vasp. \\n\\n- 0: no electron temperature. \\n\\n- 1: eletron temperature as frame parameter. \\n\\n- 2: electron temperature as atom parameter.","repeat":false,"sub_fields":{},"sub_variants":{},"default":0},"init_data_prefix":{"object":"Argument","name":"init_data_prefix","type":["str"],"optional":true,"alias":[],"doc":"Prefix of initial data directories.","repeat":false,"sub_fields":{},"sub_variants":{}},"init_data_sys":{"object":"Argument","name":"init_data_sys","type":["list"],"optional":false,"alias":[],"doc":"Paths of initial data. The path can be either a system diretory containing NumPy files or an HDF5 file. You may use either absolute or relative path here. Systems will be detected recursively in the directories or the HDF5 file.","repeat":false,"sub_fields":{},"sub_variants":{}},"sys_format":{"object":"Argument","name":"sys_format","type":["str"],"optional":true,"alias":[],"doc":"Format of sys_configs.","repeat":false,"sub_fields":{},"sub_variants":{},"default":"vasp/poscar"},"init_batch_size":{"object":"Argument","name":"init_batch_size","type":["str","list"],"optional":true,"alias":[],"doc":"Each number is the batch_size of corresponding system for training in init_data_sys. One recommended rule for setting the sys_batch_size and init_batch_size is that batch_size mutiply number of atoms ot the stucture should be larger than 32. If set to auto, batch size will be 32 divided by number of atoms. This argument will not override the mixed batch size in `default_training_param`.","repeat":false,"sub_fields":{},"sub_variants":{}},"sys_configs_prefix":{"object":"Argument","name":"sys_configs_prefix","type":["str"],"optional":true,"alias":[],"doc":"Prefix of sys_configs.","repeat":false,"sub_fields":{},"sub_variants":{}},"sys_configs":{"object":"Argument","name":"sys_configs","type":["list"],"optional":false,"alias":[],"doc":"2D list. Containing directories of structures to be explored in iterations for each system. Wildcard characters are supported here.","repeat":false,"sub_fields":{},"sub_variants":{}},"sys_batch_size":{"object":"Argument","name":"sys_batch_size","type":["list"],"optional":true,"alias":[],"doc":"Each number is the batch_size for training of corresponding system in sys_configs. If set to auto, batch size will be 32 divided by number of atoms. This argument will not override the mixed batch size in `default_training_param`.","repeat":false,"sub_fields":{},"sub_variants":{}},"numb_models":{"object":"Argument","name":"numb_models","type":["int"],"optional":false,"alias":[],"doc":"Number of models to be trained in 00.train. 4 is recommend.","repeat":false,"sub_fields":{},"sub_variants":{}},"training_iter0_model_path":{"object":"Argument","name":"training_iter0_model_path","type":["list"],"optional":true,"alias":[],"doc":"The model used to init the first iter training. Number of element should be equal to numb_models.","repeat":false,"sub_fields":{},"sub_variants":{}},"training_init_model":{"object":"Argument","name":"training_init_model","type":["bool"],"optional":true,"alias":[],"doc":"Iteration > 0, the model parameters will be initilized from the model trained at the previous iteration. Iteration == 0, the model parameters will be initialized from training_iter0_model_path.","repeat":false,"sub_fields":{},"sub_variants":{}},"default_training_param":{"object":"Argument","name":"default_training_param","type":["dict"],"optional":false,"alias":[],"doc":"Training parameters for deepmd-kit in 00.train. You can find instructions from `DeePMD-kit documentation <https://docs.deepmodeling.org/projects/deepmd/>`_.","repeat":false,"sub_fields":{},"sub_variants":{}},"dp_train_skip_neighbor_stat":{"object":"Argument","name":"dp_train_skip_neighbor_stat","type":["bool"],"optional":true,"alias":[],"doc":"Append --skip-neighbor-stat flag to dp train.","repeat":false,"sub_fields":{},"sub_variants":{},"default":false},"dp_compress":{"object":"Argument","name":"dp_compress","type":["bool"],"optional":true,"alias":[],"doc":"Use dp compress to compress the model.","repeat":false,"sub_fields":{},"sub_variants":{},"default":false},"training_reuse_iter":{"object":"Argument","name":"training_reuse_iter","type":["NoneType","int"],"optional":true,"alias":[],"doc":"The minimal index of iteration that continues training models from old models of last iteration.","repeat":false,"sub_fields":{},"sub_variants":{}},"training_reuse_old_ratio":{"object":"Argument","name":"training_reuse_old_ratio","type":["str","float"],"optional":true,"alias":[],"doc":"The probability proportion of old data during training. It can be:\\n\\n- float: directly assign the probability of old data;\\n- `auto:f`: automatic probability, where f is the new-to-old ratio;\\n- `auto`: equivalent to `auto:10`.\\n This option is only adopted when continuing training models from old models. This option will override default parameters.","repeat":false,"sub_fields":{},"sub_variants":{},"default":"auto"},"training_reuse_numb_steps":{"object":"Argument","name":"training_reuse_numb_steps","type":["NoneType","int"],"optional":true,"alias":["training_reuse_stop_batch"],"doc":"Number of training batch. This option is only adopted when continuing training models from old models. This option will override default parameters.","repeat":false,"sub_fields":{},"sub_variants":{},"default":null},"training_reuse_start_lr":{"object":"Argument","name":"training_reuse_start_lr","type":["NoneType","float"],"optional":true,"alias":[],"doc":"The learning rate the start of the training. This option is only adopted when continuing training models from old models. This option will override default parameters.","repeat":false,"sub_fields":{},"sub_variants":{},"default":null},"training_reuse_start_pref_e":{"object":"Argument","name":"training_reuse_start_pref_e","type":["NoneType","float","int"],"optional":true,"alias":[],"doc":"The prefactor of energy loss at the start of the training. This option is only adopted when continuing training models from old models. This option will override default parameters.","repeat":false,"sub_fields":{},"sub_variants":{},"default":null},"training_reuse_start_pref_f":{"object":"Argument","name":"training_reuse_start_pref_f","type":["NoneType","float","int"],"optional":true,"alias":[],"doc":"The prefactor of force loss at the start of the training. This option is only adopted when continuing training models from old models. This option will override default parameters.","repeat":false,"sub_fields":{},"sub_variants":{},"default":null},"model_devi_activation_func":{"object":"Argument","name":"model_devi_activation_func","type":["NoneType","list"],"optional":true,"alias":[],"doc":"The activation function in the model. The shape of list should be (N_models, 2), where 2 represents the embedding and fitting network. This option will override default parameters.","repeat":false,"sub_fields":{},"sub_variants":{}},"srtab_file_path":{"object":"Argument","name":"srtab_file_path","type":["str"],"optional":true,"alias":[],"doc":"The path of the table for the short-range pairwise interaction which is needed when using DP-ZBL potential","repeat":false,"sub_fields":{},"sub_variants":{}},"one_h5":{"object":"Argument","name":"one_h5","type":["bool"],"optional":true,"alias":[],"doc":"When using DeePMD-kit, all of the input data will be merged into one HDF5 file.","repeat":false,"sub_fields":{},"sub_variants":{},"default":false},"training_init_frozen_model":{"object":"Argument","name":"training_init_frozen_model","type":["list"],"optional":true,"alias":[],"doc":"At interation 0, initilize the model parameters from the given frozen models. Number of element should be equal to numb_models.","repeat":false,"sub_fields":{},"sub_variants":{}},"training_finetune_model":{"object":"Argument","name":"training_finetune_model","type":["list"],"optional":true,"alias":[],"doc":"At interation 0, finetune the model parameters from the given frozen models. Number of element should be equal to numb_models.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_task_max":{"object":"Argument","name":"fp_task_max","type":["int"],"optional":false,"alias":[],"doc":"Maximum number of structures to be calculated in each system in 02.fp of each iteration. If the number of candidate structures exceeds `fp_task_max`, `fp_task_max` structures will be randomly picked from the candidates and labeled.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_task_min":{"object":"Argument","name":"fp_task_min","type":["int"],"optional":false,"alias":[],"doc":"Skip the training in the next iteration if the number of structures is no more than `fp_task_min`.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_accurate_threshold":{"object":"Argument","name":"fp_accurate_threshold","type":["float"],"optional":true,"alias":[],"doc":"If the accurate ratio is larger than this number, no fp calculation will be performed, i.e. fp_task_max = 0.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_accurate_soft_threshold":{"object":"Argument","name":"fp_accurate_soft_threshold","type":["float"],"optional":true,"alias":[],"doc":"If the accurate ratio is between this number and fp_accurate_threshold, the fp_task_max linearly decays to zero.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_cluster_vacuum":{"object":"Argument","name":"fp_cluster_vacuum","type":["float"],"optional":true,"alias":[],"doc":"If the vacuum size is smaller than this value, this cluster will not be chosen for labeling.","repeat":false,"sub_fields":{},"sub_variants":{}},"detailed_report_make_fp":{"object":"Argument","name":"detailed_report_make_fp","type":["bool"],"optional":true,"alias":[],"doc":"If set to true, a detailed report will be generated for each iteration.","repeat":false,"sub_fields":{},"sub_variants":{},"default":true},"ratio_failed":{"object":"Argument","name":"ratio_failed","type":["float"],"optional":true,"alias":[],"doc":"Check the ratio of unsuccessfully terminated jobs. If too many FP tasks are not converged, RuntimeError will be raised.","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{"model_devi_engine":{"object":"Variant","flag_name":"model_devi_engine","optional":true,"default_tag":"lammps","choice_dict":{"lammps":{"object":"Argument","name":"lammps","type":["dict"],"optional":false,"alias":[],"doc":"LAMMPS","repeat":false,"sub_fields":{"model_devi_jobs":{"object":"Argument","name":"model_devi_jobs","type":["list"],"optional":false,"alias":[],"doc":"Settings for exploration in 01.model_devi. Each dict in the list corresponds to one iteration. The index of model_devi_jobs exactly accord with index of iterations","repeat":true,"sub_fields":{"template":{"object":"Argument","name":"template","type":["dict"],"optional":true,"alias":[],"doc":"Give an input file template for the supported engine software adopted in 01.model_devi. Through user-defined template, any freedom (function) that is permitted by the engine software could be inherited (invoked) in the workflow.","repeat":false,"sub_fields":{"lmp":{"object":"Argument","name":"lmp","type":["str"],"optional":true,"alias":[],"doc":"The path to input.lammps template. Instructions can be found in `LAMMPS documentation <https://docs.lammps.org/>`_.","repeat":false,"sub_fields":{},"sub_variants":{}},"plm":{"object":"Argument","name":"plm","type":["str"],"optional":true,"alias":[],"doc":"The path to input.plumed template. Instructions can be found in `PLUMED documentation <https://www.plumed.org/doc>`_.","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}},"rev_mat":{"object":"Argument","name":"rev_mat","type":["dict"],"optional":true,"alias":[],"doc":"revise matrix for revising variable(s) defined in the template into the specific values (iteration-resolved). Values will be broadcasted for all tasks within the iteration invoking this key.","repeat":false,"sub_fields":{"lmp":{"object":"Argument","name":"lmp","type":["dict"],"optional":true,"alias":[],"doc":"revise matrix for revising variable(s) defined in the lammps template into the specific values (iteration-resolved).","repeat":false,"sub_fields":{},"sub_variants":{}},"plm":{"object":"Argument","name":"plm","type":["dict"],"optional":true,"alias":[],"doc":"revise matrix for revising variable(s) defined in the plumed template into specific values(iteration-resolved)","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}},"sys_rev_mat":{"object":"Argument","name":"sys_rev_mat","type":["dict"],"optional":true,"alias":[],"doc":"system-resolved revise matrix for revising variable(s) defined in the template into specific values. Values should be individually assigned to each system adopted by this iteration, through a dictionary where first-level keys are values of sys_idx of this iteration.","repeat":false,"sub_fields":{},"sub_variants":{}},"sys_idx":{"object":"Argument","name":"sys_idx","type":["list"],"optional":false,"alias":[],"doc":"Systems to be selected as the initial structure of MD and be explored. The index corresponds exactly to the sys_configs.","repeat":false,"sub_fields":{},"sub_variants":{}},"temps":{"object":"Argument","name":"temps","type":["list"],"optional":true,"alias":[],"doc":"Temperature (K) in MD.","repeat":false,"sub_fields":{},"sub_variants":{}},"press":{"object":"Argument","name":"press","type":["list"],"optional":true,"alias":[],"doc":"Pressure (Bar) in MD. Required when ensemble is npt.","repeat":false,"sub_fields":{},"sub_variants":{}},"trj_freq":{"object":"Argument","name":"trj_freq","type":["int"],"optional":false,"alias":[],"doc":"Frequecy of trajectory saved in MD.","repeat":false,"sub_fields":{},"sub_variants":{}},"nsteps":{"object":"Argument","name":"nsteps","type":["int"],"optional":true,"alias":[],"doc":"Running steps of MD. It is not optional when not using a template.","repeat":false,"sub_fields":{},"sub_variants":{}},"nbeads":{"object":"Argument","name":"nbeads","type":["int"],"optional":true,"alias":[],"doc":"Number of beads in PIMD. If not given, classical MD will be performed. Only supported for LAMMPS version >= 20230615.","repeat":false,"sub_fields":{},"sub_variants":{}},"ensemble":{"object":"Argument","name":"ensemble","type":["str"],"optional":true,"alias":[],"doc":"Determining which ensemble used in MD, options include “npt” and “nvt”. It is not optional when not using a template.","repeat":false,"sub_fields":{},"sub_variants":{}},"neidelay":{"object":"Argument","name":"neidelay","type":["int"],"optional":true,"alias":[],"doc":"delay building until this many steps since last build.","repeat":false,"sub_fields":{},"sub_variants":{}},"taut":{"object":"Argument","name":"taut","type":["float"],"optional":true,"alias":[],"doc":"Coupling time of thermostat (ps).","repeat":false,"sub_fields":{},"sub_variants":{}},"taup":{"object":"Argument","name":"taup","type":["float"],"optional":true,"alias":[],"doc":"Coupling time of barostat (ps).","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_f_trust_lo":{"object":"Argument","name":"model_devi_f_trust_lo","type":["dict","float"],"optional":true,"alias":[],"doc":"Lower bound of forces for the selection. If dict, should be set for each index in sys_idx, respectively.","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_f_trust_hi":{"object":"Argument","name":"model_devi_f_trust_hi","type":["dict","float"],"optional":true,"alias":[],"doc":"Upper bound of forces for the selection. If dict, should be set for each index in sys_idx, respectively.","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_v_trust_lo":{"object":"Argument","name":"model_devi_v_trust_lo","type":["dict","float"],"optional":true,"alias":[],"doc":"Lower bound of virial for the selection. If dict, should be set for each index in sys_idx, respectively. Should be used with DeePMD-kit v2.x.","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_v_trust_hi":{"object":"Argument","name":"model_devi_v_trust_hi","type":["dict","float"],"optional":true,"alias":[],"doc":"Upper bound of virial for the selection. If dict, should be set for each index in sys_idx, respectively. Should be used with DeePMD-kit v2.x.","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}},"model_devi_dt":{"object":"Argument","name":"model_devi_dt","type":["float"],"optional":false,"alias":[],"doc":"Timestep for MD. 0.002 is recommend.","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_skip":{"object":"Argument","name":"model_devi_skip","type":["int"],"optional":false,"alias":[],"doc":"Number of structures skipped for fp in each MD.","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_f_trust_lo":{"object":"Argument","name":"model_devi_f_trust_lo","type":["list","dict","float"],"optional":false,"alias":[],"doc":"Lower bound of forces for the selection. If list or dict, should be set for each index in sys_configs, respectively.","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_f_trust_hi":{"object":"Argument","name":"model_devi_f_trust_hi","type":["list","dict","float"],"optional":false,"alias":[],"doc":"Upper bound of forces for the selection. If list or dict, should be set for each index in sys_configs, respectively.","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_v_trust_lo":{"object":"Argument","name":"model_devi_v_trust_lo","type":["list","dict","float"],"optional":true,"alias":[],"doc":"Lower bound of virial for the selection. If list or dict, should be set for each index in sys_configs, respectively. Should be used with DeePMD-kit v2.x.","repeat":false,"sub_fields":{},"sub_variants":{},"default":10000000000},"model_devi_v_trust_hi":{"object":"Argument","name":"model_devi_v_trust_hi","type":["list","dict","float"],"optional":true,"alias":[],"doc":"Upper bound of virial for the selection. If list or dict, should be set for each index in sys_configs, respectively. Should be used with DeePMD-kit v2.x.","repeat":false,"sub_fields":{},"sub_variants":{},"default":10000000000},"model_devi_adapt_trust_lo":{"object":"Argument","name":"model_devi_adapt_trust_lo","type":["bool"],"optional":true,"alias":[],"doc":"Adaptively determines the lower trust levels of force and virial. This option should be used together with model_devi_numb_candi_f, model_devi_numb_candi_v and optionally with model_devi_perc_candi_f and model_devi_perc_candi_v. dpgen will make two sets:\\n\\n- 1. From the frames with force model deviation lower than model_devi_f_trust_hi, select max(model_devi_numb_candi_f, model_devi_perc_candi_f*n_frames) frames with largest force model deviation. \\n\\n- 2. From the frames with virial model deviation lower than model_devi_v_trust_hi, select max(model_devi_numb_candi_v, model_devi_perc_candi_v*n_frames) frames with largest virial model deviation. \\n\\nThe union of the two sets is made as candidate dataset.","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_numb_candi_f":{"object":"Argument","name":"model_devi_numb_candi_f","type":["int"],"optional":true,"alias":[],"doc":"See model_devi_adapt_trust_lo.","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_numb_candi_v":{"object":"Argument","name":"model_devi_numb_candi_v","type":["int"],"optional":true,"alias":[],"doc":"See model_devi_adapt_trust_lo.","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_perc_candi_f":{"object":"Argument","name":"model_devi_perc_candi_f","type":["float"],"optional":true,"alias":[],"doc":"See model_devi_adapt_trust_lo.","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_perc_candi_v":{"object":"Argument","name":"model_devi_perc_candi_v","type":["float"],"optional":true,"alias":[],"doc":"See model_devi_adapt_trust_lo.","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_f_avg_relative":{"object":"Argument","name":"model_devi_f_avg_relative","type":["bool"],"optional":true,"alias":[],"doc":"Normalized the force model deviations by the RMS force magnitude along the trajectory. This key should not be used with use_relative.","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_clean_traj":{"object":"Argument","name":"model_devi_clean_traj","type":["int","bool"],"optional":true,"alias":[],"doc":"If type of model_devi_clean_traj is bool type then it denote whether to clean traj folders in MD since they are too large. If it is Int type, then the most recent n iterations of traj folders will be retained, others will be removed.","repeat":false,"sub_fields":{},"sub_variants":{},"default":true},"model_devi_merge_traj":{"object":"Argument","name":"model_devi_merge_traj","type":["bool"],"optional":true,"alias":[],"doc":"If model_devi_merge_traj is set as True, only all.lammpstrj will be generated, instead of lots of small traj files.","repeat":false,"sub_fields":{},"sub_variants":{},"default":false},"model_devi_nopbc":{"object":"Argument","name":"model_devi_nopbc","type":["bool"],"optional":true,"alias":[],"doc":"Assume open boundary condition in MD simulations.","repeat":false,"sub_fields":{},"sub_variants":{},"default":false},"model_devi_plumed":{"object":"Argument","name":"model_devi_plumed","type":["bool"],"optional":true,"alias":[],"doc":"","repeat":false,"sub_fields":{},"sub_variants":{},"default":false},"model_devi_plumed_path":{"object":"Argument","name":"model_devi_plumed_path","type":["bool"],"optional":true,"alias":[],"doc":"","repeat":false,"sub_fields":{},"sub_variants":{},"default":false},"shuffle_poscar":{"object":"Argument","name":"shuffle_poscar","type":["bool"],"optional":true,"alias":[],"doc":"Shuffle atoms of each frame before running simulations. The purpose is to sample the element occupation of alloys.","repeat":false,"sub_fields":{},"sub_variants":{},"default":false},"use_relative":{"object":"Argument","name":"use_relative","type":["bool"],"optional":true,"alias":[],"doc":"Calculate relative force model deviation.","repeat":false,"sub_fields":{},"sub_variants":{},"default":false},"epsilon":{"object":"Argument","name":"epsilon","type":["float"],"optional":true,"alias":[],"doc":"The level parameter for computing the relative force model deviation.","repeat":false,"sub_fields":{},"sub_variants":{}},"use_relative_v":{"object":"Argument","name":"use_relative_v","type":["bool"],"optional":true,"alias":[],"doc":"Calculate relative virial model deviation.","repeat":false,"sub_fields":{},"sub_variants":{},"default":false},"epsilon_v":{"object":"Argument","name":"epsilon_v","type":["float"],"optional":true,"alias":[],"doc":"The level parameter for computing the relative virial model deviation.","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}},"amber":{"object":"Argument","name":"amber","type":["dict"],"optional":false,"alias":[],"doc":"Amber DPRc engine. The command argument in the machine file should be path to sander.","repeat":false,"sub_fields":{"model_devi_jobs":{"object":"Argument","name":"model_devi_jobs","type":["list"],"optional":false,"alias":[],"doc":"List of dicts. The list including the dict for information of each cycle.","repeat":true,"sub_fields":{"sys_idx":{"object":"Argument","name":"sys_idx","type":["list"],"optional":false,"alias":[],"doc":"List of ints. List of systems to run.","repeat":false,"sub_fields":{},"sub_variants":{}},"trj_freq":{"object":"Argument","name":"trj_freq","type":["int"],"optional":false,"alias":[],"doc":"Frequency to dump trajectory.","repeat":false,"sub_fields":{},"sub_variants":{}},"restart_from_iter":{"object":"Argument","name":"restart_from_iter","type":["int"],"optional":true,"alias":[],"doc":"The iteration index to restart the simulation from. If not given, the simulation is restarted from `sys_configs`.","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}},"low_level":{"object":"Argument","name":"low_level","type":["str"],"optional":false,"alias":[],"doc":"Low level method. The value will be filled into mdin file as @qm_theory@.","repeat":false,"sub_fields":{},"sub_variants":{}},"cutoff":{"object":"Argument","name":"cutoff","type":["float"],"optional":false,"alias":[],"doc":"Cutoff radius for the DPRc model.","repeat":false,"sub_fields":{},"sub_variants":{}},"parm7_prefix":{"object":"Argument","name":"parm7_prefix","type":["str"],"optional":true,"alias":[],"doc":"The path prefix to AMBER PARM7 files.","repeat":false,"sub_fields":{},"sub_variants":{}},"parm7":{"object":"Argument","name":"parm7","type":["list"],"optional":false,"alias":[],"doc":"List of paths to AMBER PARM7 files. Each file maps to a system.","repeat":false,"sub_fields":{},"sub_variants":{}},"mdin_prefix":{"object":"Argument","name":"mdin_prefix","type":["str"],"optional":true,"alias":[],"doc":"The path prefix to AMBER mdin template files.","repeat":false,"sub_fields":{},"sub_variants":{}},"mdin":{"object":"Argument","name":"mdin","type":["list"],"optional":false,"alias":[],"doc":"List of paths to AMBER mdin template files. Each files maps to a system. In the template, the following keywords will be replaced by the actual value: `@freq@`: freq to dump trajectory; `@nstlim@`: total time step to run; `@qm_region@`: AMBER mask of the QM region; `@qm_theory@`: The low level QM theory, such as DFTB2; `@qm_charge@`: The total charge of the QM theory, such as -2; `@rcut@`: cutoff radius of the DPRc model; `@GRAPH_FILE0@`, `@GRAPH_FILE1@`, ... : graph files.","repeat":false,"sub_fields":{},"sub_variants":{}},"qm_region":{"object":"Argument","name":"qm_region","type":["list"],"optional":false,"alias":[],"doc":"List of strings. AMBER mask of the QM region. Each mask maps to a system.","repeat":false,"sub_fields":{},"sub_variants":{}},"qm_charge":{"object":"Argument","name":"qm_charge","type":["list"],"optional":false,"alias":[],"doc":"List of ints. Charge of the QM region. Each charge maps to a system.","repeat":false,"sub_fields":{},"sub_variants":{}},"nsteps":{"object":"Argument","name":"nsteps","type":["list"],"optional":false,"alias":[],"doc":"List of ints. The number of steps to run. Each number maps to a system.","repeat":false,"sub_fields":{},"sub_variants":{}},"r":{"object":"Argument","name":"r","type":["list"],"optional":false,"alias":[],"doc":"2D or 3D list of floats. Constrict values for the enhanced sampling. The first dimension maps to systems. The second dimension maps to confs in each system. The third dimension is the constrict value. It can be a single float for 1D or list of floats for nD.","repeat":false,"sub_fields":{},"sub_variants":{}},"disang_prefix":{"object":"Argument","name":"disang_prefix","type":["str"],"optional":true,"alias":[],"doc":"The path prefix to disang prefix.","repeat":false,"sub_fields":{},"sub_variants":{}},"disang":{"object":"Argument","name":"disang","type":["list"],"optional":false,"alias":[],"doc":"List of paths to AMBER disang files. Each file maps to a sytem. The keyword RVAL will be replaced by the constrict values, or RVAL1, RVAL2, ... for an nD system.","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_f_trust_lo":{"object":"Argument","name":"model_devi_f_trust_lo","type":["list","dict","float"],"optional":false,"alias":[],"doc":"Lower bound of forces for the selection. If dict, should be set for each index in sys_idx, respectively.","repeat":false,"sub_fields":{},"sub_variants":{}},"model_devi_f_trust_hi":{"object":"Argument","name":"model_devi_f_trust_hi","type":["list","dict","float"],"optional":false,"alias":[],"doc":"Upper bound of forces for the selection. If dict, should be set for each index in sys_idx, respectively.","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}},"calypso":{"object":"Argument","name":"calypso","type":["dict"],"optional":false,"alias":[],"doc":"TODO: add doc","repeat":false,"sub_fields":{},"sub_variants":{}},"gromacs":{"object":"Argument","name":"gromacs","type":["dict"],"optional":false,"alias":[],"doc":"TODO: add doc","repeat":false,"sub_fields":{},"sub_variants":{}}},"choice_alias":{},"doc":"Engine for the model deviation task."},"fp_style":{"object":"Variant","flag_name":"fp_style","optional":false,"default_tag":"","choice_dict":{"vasp":{"object":"Argument","name":"vasp","type":["dict"],"optional":false,"alias":[],"doc":"","repeat":false,"sub_fields":{"fp_pp_path":{"object":"Argument","name":"fp_pp_path","type":["str"],"optional":false,"alias":[],"doc":"Directory of psuedo-potential file to be used for 02.fp exists.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_pp_files":{"object":"Argument","name":"fp_pp_files","type":["list"],"optional":false,"alias":[],"doc":"Psuedo-potential file to be used for 02.fp. Note that the order of elements should correspond to the order in type_map.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_incar":{"object":"Argument","name":"fp_incar","type":["str"],"optional":false,"alias":[],"doc":"Input file for VASP. INCAR must specify KSPACING and KGAMMA.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_aniso_kspacing":{"object":"Argument","name":"fp_aniso_kspacing","type":["list"],"optional":true,"alias":[],"doc":"Set anisotropic kspacing. Usually useful for 1-D or 2-D materials. Only support VASP. If it is setting the KSPACING key in INCAR will be ignored.","repeat":false,"sub_fields":{},"sub_variants":{}},"cvasp":{"object":"Argument","name":"cvasp","type":["bool"],"optional":true,"alias":[],"doc":"If cvasp is true, DP-GEN will use Custodian to help control VASP calculation.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_skip_bad_box":{"object":"Argument","name":"fp_skip_bad_box","type":["str"],"optional":true,"alias":[],"doc":"Skip the configurations that are obviously unreasonable before 02.fp","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}},"gaussian":{"object":"Argument","name":"gaussian","type":["dict"],"optional":false,"alias":[],"doc":"","repeat":false,"sub_fields":{"use_clusters":{"object":"Argument","name":"use_clusters","type":["bool"],"optional":true,"alias":[],"doc":"If set to true, clusters will be taken instead of the whole system.","repeat":false,"sub_fields":{},"sub_variants":{},"default":false},"cluster_cutoff":{"object":"Argument","name":"cluster_cutoff","type":["float"],"optional":true,"alias":[],"doc":"The soft cutoff radius of clusters if `use_clusters` is set to true. Molecules will be taken as whole even if part of atoms is out of the cluster. Use `cluster_cutoff_hard` to only take atoms within the hard cutoff radius.","repeat":false,"sub_fields":{},"sub_variants":{}},"cluster_cutoff_hard":{"object":"Argument","name":"cluster_cutoff_hard","type":["float"],"optional":true,"alias":[],"doc":"The hard cutoff radius of clusters if `use_clusters` is set to true. Outside the hard cutoff radius, atoms will not be taken even if they are in a molecule where some atoms are within the cutoff radius.","repeat":false,"sub_fields":{},"sub_variants":{}},"cluster_minify":{"object":"Argument","name":"cluster_minify","type":["bool"],"optional":true,"alias":[],"doc":"If enabled, when an atom within the soft cutoff radius connects a single bond with a non-hydrogen atom out of the soft cutoff radius, the outer atom will be replaced by a hydrogen atom. When the outer atom is a hydrogen atom, the outer atom will be kept. In this case, other atoms out of the soft cutoff radius will be removed.","repeat":false,"sub_fields":{},"sub_variants":{},"default":false},"fp_params":{"object":"Argument","name":"fp_params","type":["dict"],"optional":false,"alias":[],"doc":"Parameters for Gaussian calculation.","repeat":false,"sub_fields":{"keywords":{"object":"Argument","name":"keywords","type":["list","str"],"optional":false,"alias":[],"doc":"Keywords for Gaussian input, e.g. force b3lyp/6-31g**. If a list, run multiple steps.","repeat":false,"sub_fields":{},"sub_variants":{}},"multiplicity":{"object":"Argument","name":"multiplicity","type":["int","str"],"optional":true,"alias":[],"doc":"Spin multiplicity for Gaussian input. If `auto`, multiplicity will be detected automatically, with the following rules: when fragment_guesses=True, multiplicity will +1 for each radical, and +2 for each oxygen molecule; when fragment_guesses=False, multiplicity will be 1 or 2, but +2 for each oxygen molecule.","repeat":false,"sub_fields":{},"sub_variants":{},"default":"auto"},"nproc":{"object":"Argument","name":"nproc","type":["int"],"optional":false,"alias":[],"doc":"The number of processors for Gaussian input.","repeat":false,"sub_fields":{},"sub_variants":{}},"charge":{"object":"Argument","name":"charge","type":["int"],"optional":true,"alias":[],"doc":"Molecule charge. Only used when charge is not provided by the system.","repeat":false,"sub_fields":{},"sub_variants":{},"default":0},"fragment_guesses":{"object":"Argument","name":"fragment_guesses","type":["bool"],"optional":true,"alias":[],"doc":"Initial guess generated from fragment guesses. If True, `multiplicity` should be `auto`.","repeat":false,"sub_fields":{},"sub_variants":{},"default":false},"basis_set":{"object":"Argument","name":"basis_set","type":["str"],"optional":true,"alias":[],"doc":"Custom basis set.","repeat":false,"sub_fields":{},"sub_variants":{}},"keywords_high_multiplicity":{"object":"Argument","name":"keywords_high_multiplicity","type":["str"],"optional":true,"alias":[],"doc":"Keywords for points with multiple raicals. `multiplicity` should be `auto`. If not set, fallback to normal keywords.","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}}},"sub_variants":{}},"siesta":{"object":"Argument","name":"siesta","type":["dict"],"optional":false,"alias":[],"doc":"","repeat":false,"sub_fields":{"use_clusters":{"object":"Argument","name":"use_clusters","type":["bool"],"optional":true,"alias":[],"doc":"If set to true, clusters will be taken instead of the whole system. This option does not work with DeePMD-kit 0.x.","repeat":false,"sub_fields":{},"sub_variants":{}},"cluster_cutoff":{"object":"Argument","name":"cluster_cutoff","type":["float"],"optional":true,"alias":[],"doc":"The cutoff radius of clusters if use_clusters is set to true.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_params":{"object":"Argument","name":"fp_params","type":["dict"],"optional":false,"alias":[],"doc":"Parameters for siesta calculation.","repeat":false,"sub_fields":{"ecut":{"object":"Argument","name":"ecut","type":["int"],"optional":false,"alias":[],"doc":"Define the plane wave cutoff for grid.","repeat":false,"sub_fields":{},"sub_variants":{}},"ediff":{"object":"Argument","name":"ediff","type":["float"],"optional":false,"alias":[],"doc":"Tolerance of Density Matrix.","repeat":false,"sub_fields":{},"sub_variants":{}},"kspacing":{"object":"Argument","name":"kspacing","type":["float"],"optional":false,"alias":[],"doc":"Sample factor in Brillouin zones.","repeat":false,"sub_fields":{},"sub_variants":{}},"mixingWeight":{"object":"Argument","name":"mixingWeight","type":["float"],"optional":false,"alias":[],"doc":"Proportion a of output Density Matrix to be used for the input Density Matrix of next SCF cycle (linear mixing).","repeat":false,"sub_fields":{},"sub_variants":{}},"NumberPulay":{"object":"Argument","name":"NumberPulay","type":["int"],"optional":false,"alias":[],"doc":"Controls the Pulay convergence accelerator.","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}},"fp_pp_path":{"object":"Argument","name":"fp_pp_path","type":["str"],"optional":false,"alias":[],"doc":"Directory of psuedo-potential or numerical orbital files to be used for 02.fp exists.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_pp_files":{"object":"Argument","name":"fp_pp_files","type":["list"],"optional":false,"alias":[],"doc":"Psuedo-potential file to be used for 02.fp. Note that the order of elements should correspond to the order in type_map.","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}},"cp2k":{"object":"Argument","name":"cp2k","type":["dict"],"optional":false,"alias":[],"doc":"","repeat":false,"sub_fields":{"user_fp_params":{"object":"Argument","name":"user_fp_params","type":["dict"],"optional":true,"alias":["fp_params"],"doc":"Parameters for cp2k calculation. find detail in manual.cp2k.org. only the kind section must be set before use. we assume that you have basic knowledge for cp2k input.","repeat":false,"sub_fields":{},"sub_variants":{}},"external_input_path":{"object":"Argument","name":"external_input_path","type":["str"],"optional":true,"alias":[],"doc":"Conflict with key:user_fp_params.\\nenable the template input provided by user.\\nsome rules should be followed, read the following text in detail: \\n\\n1. One must present a KEYWORD ABC in the section CELL so that the DP-GEN can replace the cell on-the-fly. \\n2. One need to add these lines under FORCE_EVAL section to print forces and stresses::\\n\\n    STRESS_TENSOR ANALYTICAL\\n      &PRINT\\n        &FORCES ON\\n        &END FORCES\\n        &STRESS_TENSOR ON\\n        &END STRESS_TENSOR\\n      &END PRINT\\n\\n","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}},"abacus":{"object":"Argument","name":"abacus","type":["dict"],"optional":false,"alias":[],"doc":"","repeat":false,"sub_fields":{"fp_pp_path":{"object":"Argument","name":"fp_pp_path","type":["str"],"optional":false,"alias":[],"doc":"Directory of psuedo-potential or numerical orbital files to be used for 02.fp exists.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_pp_files":{"object":"Argument","name":"fp_pp_files","type":["list"],"optional":false,"alias":[],"doc":"Psuedo-potential file to be used for 02.fp. Note that the order of elements should correspond to the order in type_map.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_orb_files":{"object":"Argument","name":"fp_orb_files","type":["list"],"optional":true,"alias":[],"doc":"numerical orbital file to be used for 02.fp when using LCAO basis. Note that the order of elements should correspond to the order in type_map.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_incar":{"object":"Argument","name":"fp_incar","type":["str"],"optional":true,"alias":[],"doc":"Input file for ABACUS. This is optinal but the priority is lower than user_fp_params, and you should not set user_fp_params if you want to use fp_incar.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_kpt_file":{"object":"Argument","name":"fp_kpt_file","type":["str"],"optional":true,"alias":[],"doc":"KPT file for ABACUS.If the \\"kspacing\\" or \\"gamma_only=1\\" is defined in INPUT or \\"k_points\\" is defined, fp_kpt_file will be ignored.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_dpks_descriptor":{"object":"Argument","name":"fp_dpks_descriptor","type":["str"],"optional":true,"alias":[],"doc":"DeePKS descriptor file name. The file should be in pseudopotential directory.","repeat":false,"sub_fields":{},"sub_variants":{}},"user_fp_params":{"object":"Argument","name":"user_fp_params","type":["dict"],"optional":true,"alias":[],"doc":"Set the key and value of INPUT.","repeat":false,"sub_fields":{},"sub_variants":{}},"k_points":{"object":"Argument","name":"k_points","type":["list"],"optional":true,"alias":[],"doc":"Monkhorst-Pack k-grids setting for generating KPT file of ABACUS, such as: [1,1,1,0,0,0]. NB: if \\"kspacing\\" or \\"gamma_only=1\\" is defined in INPUT, k_points will be ignored.","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}},"amber/diff":{"object":"Argument","name":"amber/diff","type":["dict"],"optional":false,"alias":[],"doc":"Amber/diff style for DPRc models. Note: this fp style only supports to be used with model_devi_engine `amber`, where some arguments are reused. The command argument in the machine file should be path to sander. One should also install dpamber and make it visible in the PATH.","repeat":false,"sub_fields":{"high_level":{"object":"Argument","name":"high_level","type":["str"],"optional":false,"alias":[],"doc":"High level method. The value will be filled into mdin template as @qm_theory@.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_params":{"object":"Argument","name":"fp_params","type":["dict"],"optional":false,"alias":[],"doc":"Parameters for FP calculation.","repeat":false,"sub_fields":{"high_level_mdin":{"object":"Argument","name":"high_level_mdin","type":["str"],"optional":false,"alias":[],"doc":"Path to high-level AMBER mdin template file. %qm_theory%, %qm_region%, and %qm_charge% will be replaced.","repeat":false,"sub_fields":{},"sub_variants":{}},"low_level_mdin":{"object":"Argument","name":"low_level_mdin","type":["str"],"optional":false,"alias":[],"doc":"Path to low-level AMBER mdin template file. %qm_theory%, %qm_region%, and %qm_charge% will be replaced.","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}}},"sub_variants":{}},"pwmat":{"object":"Argument","name":"pwmat","type":["dict"],"optional":false,"alias":[],"doc":"TODO: add doc","repeat":false,"sub_fields":{},"sub_variants":{}},"pwscf":{"object":"Argument","name":"pwscf","type":["dict"],"optional":false,"alias":[],"doc":"","repeat":false,"sub_fields":{"fp_pp_path":{"object":"Argument","name":"fp_pp_path","type":["str"],"optional":false,"alias":[],"doc":"Directory of psuedo-potential file to be used for 02.fp exists.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_pp_files":{"object":"Argument","name":"fp_pp_files","type":["list"],"optional":false,"alias":[],"doc":"Psuedo-potential file to be used for 02.fp. Note that the order of elements should correspond to the order in type_map.","repeat":false,"sub_fields":{},"sub_variants":{}},"fp_params":{"object":"Argument","name":"fp_params","type":["dict"],"optional":true,"alias":[],"doc":"Parameters for pwscf calculation. It has lower priority than user_fp_params.","repeat":false,"sub_fields":{"ecut":{"object":"Argument","name":"ecut","type":["float"],"optional":false,"alias":[],"doc":"ecutwfc in pwscf.","repeat":false,"sub_fields":{},"sub_variants":{}},"ediff":{"object":"Argument","name":"ediff","type":["float"],"optional":false,"alias":[],"doc":"conv_thr and ts_vdw_econv_thr in pwscf.","repeat":false,"sub_fields":{},"sub_variants":{}},"smearing":{"object":"Argument","name":"smearing","type":["str"],"optional":false,"alias":[],"doc":"smearing in pwscf.","repeat":false,"sub_fields":{},"sub_variants":{}},"sigma":{"object":"Argument","name":"sigma","type":["float"],"optional":false,"alias":[],"doc":"degauss in pwscf.","repeat":false,"sub_fields":{},"sub_variants":{}},"kspacing":{"object":"Argument","name":"kspacing","type":["float"],"optional":false,"alias":[],"doc":"The spacing between kpoints. Helps to determin KPOINTS in pwscf.","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}},"user_fp_params":{"object":"Argument","name":"user_fp_params","type":["dict"],"optional":true,"alias":[],"doc":"Parameters for pwscf calculation. Find details at https://www.quantum-espresso.org/Doc/INPUT_PW.html. When user_fp_params is set, the settings in fp_params will be ignored. If one wants to use user_fp_params, kspacing must be set in user_fp_params. kspacing is the spacing between kpoints, and helps to determin KPOINTS in pwscf.","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}},"custom":{"object":"Argument","name":"custom","type":["dict"],"optional":false,"alias":[],"doc":"Custom FP code. You need to provide the input and output file format and name. The command argument in the machine file should be the script to run custom FP codes. The extra forward and backward files can be defined in the machine file.","repeat":false,"sub_fields":{"fp_params":{"object":"Argument","name":"fp_params","type":["dict"],"optional":false,"alias":[],"doc":"Parameters for FP calculation.","repeat":false,"sub_fields":{"input_fmt":{"object":"Argument","name":"input_fmt","type":["str"],"optional":false,"alias":[],"doc":"Input dpdata format of the custom FP code. Such format should only need the first argument as the file name.","repeat":false,"sub_fields":{},"sub_variants":{}},"input_fn":{"object":"Argument","name":"input_fn","type":["str"],"optional":false,"alias":[],"doc":"Input file name of the custom FP code.","repeat":false,"sub_fields":{},"sub_variants":{}},"output_fmt":{"object":"Argument","name":"output_fmt","type":["str"],"optional":false,"alias":[],"doc":"Output dpata format of the custom FP code. Such format should only need the first argument as the file name.","repeat":false,"sub_fields":{},"sub_variants":{}},"output_fn":{"object":"Argument","name":"output_fn","type":["str"],"optional":false,"alias":[],"doc":"Output file name of the custom FP code.","repeat":false,"sub_fields":{},"sub_variants":{}}},"sub_variants":{}}},"sub_variants":{}}},"choice_alias":{},"doc":"Software for First Principles."}}}')}}]);
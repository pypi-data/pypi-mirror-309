# coding: utf-8

"""
    Connect API

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: v1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from trinsic_api.models.disclosed_fields_request import DisclosedFieldsRequest
from trinsic_api.models.known_identity_data import KnownIdentityData
from typing import Optional, Set
from typing_extensions import Self

class CreateSessionRequest(BaseModel):
    """
    CreateSessionRequest
    """ # noqa: E501
    launch_provider_directly: Optional[StrictBool] = Field(default=None, description="Whether to immediately launch the identity provider, without invoking the Trinsic Widget UI.                Users will not be shown the Widget; therefore, reuse of credentials, selection of an identity provider, and saving a verification for future reuse  are not available to the end user in this mode.                Sessions created with this option enabled must be created with a `RedirectUrl` specified, and cannot be invoked using the frontend SDK at this time.", alias="launchProviderDirectly")
    enable_remember_me: Optional[StrictBool] = Field(default=None, description="Whether to enable Trinsic's \"Remember Me\" feature, which allows users to save their credentials for future use.                This option is only relevant when `LaunchProviderDirectly` is unspecified or set to `false`.  If `LaunchProviderDirectly` is `true`, this field must be unspecified or set to `false`.                If this field is set to `true`, then:    - The user will be prompted to authenticate with their phone number at the start of the flow    - If the user has previously saved a verification for reuse with Trinsic, they will be offered the ability to reuse it    - After the user has verified their identity (and if the identity provider in question supports it), they will be prompted to save their credentials for future use                If this field is set to `false`, then:    - The user will not be prompted to authenticate with their phone number at the start of the flow.      - Instead, the user will be immediately shown the list of available providers    - The user will not be offered the ability to reuse a previously-saved Trinsic credential    - After the user has verified their identity, they will not be prompted to save their credentials for future use      - Instead, they will immediately return to your product", alias="enableRememberMe")
    providers: Optional[List[StrictStr]] = Field(default=None, description="The list of allowed identity providers. If not specified, all available providers will be allowed.                If `LaunchMethodDirectly` is `true`, this field must be set, and must have only a single entry.  If `LaunchMethodDirectly` is not specified or is `false`, this field may have any number of entries.")
    known_identity_data: Optional[KnownIdentityData] = Field(default=None, description="Known identity data of an individual being verified.                Provide this to Trinsic during Session creation to enable improved identity provider selection recommendations.", alias="knownIdentityData")
    disclosed_fields: Optional[DisclosedFieldsRequest] = Field(default=None, description="Specific identity attributes to request. If not provided, all available attributes will be requested.", alias="disclosedFields")
    __properties: ClassVar[List[str]] = ["launchProviderDirectly", "enableRememberMe", "providers", "knownIdentityData", "disclosedFields"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CreateSessionRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of known_identity_data
        if self.known_identity_data:
            _dict['knownIdentityData'] = self.known_identity_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of disclosed_fields
        if self.disclosed_fields:
            _dict['disclosedFields'] = self.disclosed_fields.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CreateSessionRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "launchProviderDirectly": obj.get("launchProviderDirectly"),
            "enableRememberMe": obj.get("enableRememberMe"),
            "providers": obj.get("providers"),
            "knownIdentityData": KnownIdentityData.from_dict(obj["knownIdentityData"]) if obj.get("knownIdentityData") is not None else None,
            "disclosedFields": DisclosedFieldsRequest.from_dict(obj["disclosedFields"]) if obj.get("disclosedFields") is not None else None
        })
        return _obj



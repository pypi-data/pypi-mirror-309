# generated by datamodel-codegen:
#   filename:  openapi_websocket.yml
#   timestamp: 2024-11-18T09:36:59+00:00

from __future__ import annotations

from enum import Enum
from typing import Dict, List, Optional

from pydantic import BaseModel, ConfigDict, Field, conint


class Status(Enum):
    Offline = "Offline"
    Test = "Test"
    Maintenance = "Maintenance"
    Online = "Online"


class ApiRecord(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    providerId: str = Field(
        ...,
        description="Eindeutige Kennung des verantwortlichen API-Anbieters; Hinweise in Kapitel [Einträge im Verzeichnis](#einträge-im-verzeichnis) beachten.",
    )
    apiId: str = Field(
        ...,
        description="Eindeutige Kennung des API-Webdiensts; Hinweise in Kapitel [Einträge im Verzeichnis](#einträge-im-verzeichnis) beachten.",
    )
    majorVersion: int = Field(
        ...,
        description="Major-Version des API-Webdiensts; Hinweise in Kapitel [Einträge im Verzeichnis](#einträge-im-verzeichnis) beachten.",
    )
    url: str = Field(..., description="Adresse des Endpunkts, an dem der API-Webdienst aufgerufen werden kann.")
    additionalMetadata: Optional[Dict[str, str]] = Field(
        None,
        description="Zusätzliche Informationen über den Aufruf oder die Antworten des entsprechenden API-Webdiensts in Form von Schlüssel-Wert-Paaren. Dieses Feld ist optional und es wird durch übergreifende Regelungen außerhalb dieser Spezifikation sowie durch die Spezifikation des entsprechenden API-Webdiensts festgelegt, welche Informationen zu hinterlegen sind.",
    )
    lastUpdated: str = Field(..., description="Zeitpunkt der letzten Aktualisierung des Verzeichniseintrags.")
    revision: conint(ge=1) = Field(
        ...,
        description="Fortlaufende Revisionsnummer des Verzeichniseintrags. Wird bei jeder Aktualisierung des Eintrags inkrementiert.",
    )
    status: Status = Field(
        ...,
        description="Aktueller Status des hinterlegten API-Endpunkts; Hinweise in Kapitel [Statusmodell](#statusmodell) beachten.",
    )


class ApiRecordRef(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    providerId: str = Field(
        ...,
        description="Eindeutige Kennung des verantwortlichen API-Anbieters; Hinweise in Kapitel [Einträge im Verzeichnis](#einträge-im-verzeichnis) beachten.",
    )
    apiId: str = Field(
        ...,
        description="Eindeutige Kennung des API-Webdiensts; Hinweise in Kapitel [Einträge im Verzeichnis](#einträge-im-verzeichnis) beachten.",
    )
    majorVersion: int = Field(
        ...,
        description="Major Version des API-Webdiensts; Hinweise in Kapitel [Einträge im Verzeichnis](#einträge-im-verzeichnis) beachten.",
    )


class RedirectedItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    recordRef: ApiRecordRef
    url: Optional[str] = Field(
        None, description="Konfigurierte Ziel-URL des Redirects. Ist nicht vorhanden, wenn der Redirect entfernt wurde."
    )


class CanceledItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    recordRef: ApiRecordRef
    canceledByClient: bool = Field(
        ...,
        description="Zeigt an, ob die Subscription durch den Client (true) oder durch den Server (false) beendet wurde.",
    )
    reason: Optional[str] = Field(None, description="Erläuternde Beschreibung, weshalb die Subscription beendet wurde.")


class Error(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    statusCode: conint(ge=0) = Field(..., description="HTTP Status Code, der den Fehler beschreibt.")
    description: str = Field(..., description="Informativer Text, der den Fehler beschreibt.")
    request: Optional[str] = Field(
        None, description="Base64-kodierter SubscriptionRequest, der den Fehler ausgelöst hat."
    )


class Contact(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    email: Optional[str] = Field(None, description="E-Mail-Adresse des technischen Supports.")
    phone: Optional[str] = Field(None, description="Telefonnummer des technischen Supports.")


class ServiceInfo(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    version: str = Field(
        ..., description="Vollqualifizierte Versionsnummer der implementierten Schnittstelle des Verzeichnisdiensts."
    )
    contact: Contact = Field(
        ...,
        description="Kontaktdaten des technischen Betreibers.\n\n*__Hinweis:__ Die einzelnen Felder sind OPTIONAL, jedoch MUSS mindestens eins befüllt sein.*",
    )
    lastUpdated: str = Field(..., description="Zeitpunkt der letzten Aktualisierung dieser Information.")
    revision: conint(ge=1) = Field(
        ...,
        description="Fortlaufende Revisionsnummer dieser Information. Beginnt bei 1 und wird bei jeder Aktualisierung inkrementiert.",
    )


class SignedApiRecord(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    content: ApiRecord
    signature: str = Field(
        ...,
        description="Die Signatur des Verzeichniseintrags; Hinweise in Kapitel [Signatur von Verzeichniseinträgen](#signatur-von-verzeichniseinträgen) beachten.",
    )
    signingCert: str = Field(
        ...,
        description="Das verwendete Signaturzertifikat; Hinweise in Kapitel [Signatur von Verzeichniseinträgen](#signatur-von-verzeichniseinträgen) beachten.",
    )


class RequestedItem(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    recordRef: ApiRecordRef
    knownRevision: Optional[conint(ge=0)] = Field(
        None,
        description="Beim Client bekannte Revision des angeforderten Verzeichniseintrags. Der Wert 0 oder die Abwesenheit dieses Felds bedeutet, dass dem Client kein Eintrag bekannt ist.",
    )


class SubscriptionRequest(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    id: str = Field(
        ...,
        description="ID des Subscription Requests. Wird durch den Client selbst gewählt und innerhalb des Verzeichnisdiensts nicht ausgewertet. Dieser Wert wird zur Korrelation vom Request in die dazugehörige [DirectoryNotification](#schema-DirectoryNotification) übernommen.",
    )
    requested: Optional[List[RequestedItem]] = Field(None, description="Zu erstellende Subscriptions.")
    canceled: Optional[List[ApiRecordRef]] = Field(None, description="Zu kündigende Subscriptions.")


class DirectoryNotification(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    subscriptionId: Optional[str] = Field(
        None,
        description="ID des [SubscriptionRequest](#schema-SubscriptionRequest)-Objekts, auf den sich die Benachrichtigung bezieht.",
    )
    timestamp: str = Field(
        ...,
        description="Der Zeitpunkt, an dem diese Benachrichtigung erzeugt wurde. Der Wert MUSS gemäß ISO 8601 formatiert und als UTC angeben werden.",
    )
    serviceInfo: Optional[ServiceInfo] = None
    modified: Optional[List[SignedApiRecord]] = Field(
        None, description="Hinzugefügte oder geänderte Verzeichniseinträge."
    )
    redirected: Optional[List[RedirectedItem]] = Field(
        None, description="Konfigurierte Redirects für Verzeichniseinträge."
    )
    deleted: Optional[List[ApiRecordRef]] = Field(None, description="Gelöschte Verzeichniseinträge.")
    canceled: Optional[List[CanceledItem]] = Field(None, description="Beendete Subscriptions.")
    error: Optional[Error] = None

from typing import Literal, TypeAlias, overload
from typing_extensions import TypeVar

import numpy as np
import numpy.typing as npt
import optype.numpy as onp
from scipy._typing import CorrelateMode

__all__ = [
    "block_diag",
    "circulant",
    "companion",
    "convolution_matrix",
    "dft",
    "fiedler",
    "fiedler_companion",
    "hadamard",
    "hankel",
    "helmert",
    "hilbert",
    "invhilbert",
    "invpascal",
    "kron",
    "leslie",
    "pascal",
    "toeplitz",
]

_SCT = TypeVar("_SCT", bound=np.generic, default=np.generic)

_Matrix: TypeAlias = onp.Array2D[_SCT]
_Kind: TypeAlias = Literal["symmetric", "upper", "lower"]

###

# TODO(jorenham): transparent dtypes
def toeplitz(c: npt.ArrayLike, r: npt.ArrayLike | None = None) -> _Matrix: ...
def circulant(c: npt.ArrayLike) -> _Matrix: ...
def hankel(c: npt.ArrayLike, r: npt.ArrayLike | None = None) -> _Matrix: ...
def hadamard(n: onp.ToInt, dtype: npt.DTypeLike = ...) -> _Matrix: ...
def leslie(f: npt.ArrayLike, s: npt.ArrayLike) -> _Matrix: ...
def kron(a: npt.ArrayLike, b: npt.ArrayLike) -> _Matrix: ...
def block_diag(*arrs: npt.ArrayLike) -> _Matrix: ...
def companion(a: npt.ArrayLike) -> _Matrix: ...
def helmert(n: onp.ToInt, full: bool = False) -> _Matrix[np.float64]: ...
def hilbert(n: onp.ToInt) -> _Matrix[np.float64]: ...
def fiedler(a: npt.ArrayLike) -> _Matrix: ...
def fiedler_companion(a: npt.ArrayLike) -> _Matrix: ...
def convolution_matrix(a: npt.ArrayLike, n: onp.ToInt, mode: CorrelateMode = "full") -> _Matrix: ...

#
@overload
def invhilbert(n: onp.ToInt, exact: Literal[False] = False) -> _Matrix[np.float64]: ...
@overload
def invhilbert(n: onp.ToInt, exact: Literal[True]) -> _Matrix[np.int64] | _Matrix[np.object_]: ...
@overload
def pascal(n: onp.ToInt, kind: _Kind = "symmetric", exact: Literal[True] = True) -> _Matrix[np.uint64 | np.object_]: ...
@overload
def pascal(n: onp.ToInt, kind: _Kind = "symmetric", *, exact: Literal[False]) -> _Matrix[np.float64]: ...
@overload
def pascal(n: onp.ToInt, kind: _Kind, exact: Literal[False]) -> _Matrix[np.float64]: ...
@overload
def invpascal(n: onp.ToInt, kind: _Kind = "symmetric", exact: Literal[True] = True) -> _Matrix[np.int64 | np.object_]: ...
@overload
def invpascal(n: onp.ToInt, kind: _Kind = "symmetric", *, exact: Literal[False]) -> _Matrix[np.float64]: ...
@overload
def invpascal(n: onp.ToInt, kind: _Kind, exact: Literal[False]) -> _Matrix[np.float64]: ...
def dft(n: onp.ToInt, scale: Literal["sqrtn", "n"] | None = None) -> _Matrix[np.complex128]: ...

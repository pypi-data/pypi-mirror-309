\section{Implementation Details}
\label{sec:algo}

\subsection{Parsing Query Plans and Tree Genreating}

A QEP is generated by PostgreSQL with the SQL statement:
\begin{lstlisting}
EXPLAIN <QUERY>;
\end{lstlisting}
A parser is created to parse the output of the generated QEP. We assume $\textsc{Parse}(p_i)$ function can extract the information of the plan and convert it to a node, $\textsc{Depth}(p_i)$ function can retrieve the depth of the plan. $\textsc{Depth}(p_0) = 0$.

The whole process generation QEP tree is DFS with backtracking, described in Algorithm \ref{alg:generate-execution-tree}.

The tree structure is explained in Section~\ref{sec:execution_tree_node} and \ref{sec:execution_tree}.

\begin{algorithm}[ht]
\caption{$\textsc{GenerateExecutionTree}(p)$}
\label{alg:generate-execution-tree}
\begin{algorithmic}[1]
\Require A list of strings representing query plans $p$ from PostgreSQL
\Ensure An \textsc{ExecutionTree} representing the QEP
\State $\mathcal{T}\leftarrow$ Empty Tree
\State $o\leftarrow \textsc{Parse}(p_0)$\Comment{$o$ is the current node}
\State $\textsc{Root}(\mathcal{T})\leftarrow o$\Comment{Set $o$ to be the root of $\mathcal{T}$}
\State $d\leftarrow 0$\Comment{Currently depth is $0$}
\For{$i\in 1\dots \textsc{Len}(p)-1$}\Comment{Enumerate remaining plans}
    \State $o'\leftarrow \textsc{Parse}(p_i)$\Comment{Current node}
    \State $d'\leftarrow \textsc{Depth}(p_i)$\Comment{Current depth}
    \While{$d'\le d$}\Comment{Backtrack to Find Parent of $o$}
    \State $o\leftarrow\textsc{Parent}(o)$
    \State $d\leftarrow d - 1$
    \EndWhile
    \State $\textsc{Parent}(o')\leftarrow o$\Comment{Set the parent of $o'$ to $o$}
    % 就是我感觉我们这个 algo 是不是应该强调建树的过程，而不是 parse 的过程
    % \If{`\texttt{:}'$\in \ell$}\Comment{$\ell$ contains a condition}
    %     \State Add the condition to the current node
    % \ElsIf{`\texttt{->}'$\in\ell$}\Comment{$\ell$ contains an operation}
    %     \State Create a new node for the operation
    %     \State Determine the node's level in the tree based on indentation (arrow positions)
    %     \State Link the node to its parent in the tree hierarchy
    % \EndIf
\EndFor

\State \Return $\mathcal{T}$
\end{algorithmic}
\end{algorithm}


\subsection{\textsc{ExecutionTreeNode} Class}
\label{sec:execution_tree_node}

The \textsc{ExecutionTreeNode} class represents a single node in the execution tree. Each node corresponds to a query operation (e.g., Hash Join, Seq Scan) and includes metadata like costs and conditions associated with that query operation.

Table \ref{tab:ExecutionTreeNode_attributes} lists the key attributes and methods for \textsc{ExecutionTreeNode}.

\begin{table}[ht]
    \centering
    \begin{tabular}{l|l}
    \toprule
        \textbf{Attributes / Methods} & \textbf{Description} \\
    \midrule
        Operation & The query operation. \\
        Conditions & Filters or keys associated with the operation.\\
        Startup Cost & Startup cost for the operation.\\
        Total Cost & Total cost for the operation.\\
        Children & Child nodes representing sub-operations.\\
    \midrule
        Set Operation & Parses the operation and perform estimation.\\
        Natural Language & Converts the operations into a human-readable format.\\
        Explain & Returns the detailed estimation to the operation. \\
    \bottomrule
    \end{tabular}
    \caption{Key Attributes and Methods for \textsc{ExecutionTreeNode}}
    \label{tab:ExecutionTreeNode_attributes}
\end{table}


\subsection{\textsc{ExecutionTree} Class}
\label{sec:execution_tree}

The \textsc{ExecutionTree} class organizes query operations into a hierarchical structure, allowing traversal and cost analysis. Table \ref{tab:ExecutionTree_attributes} lists key attributes and methods of \textsc{ExecutionTree}.

\begin{table}[ht]
    \centering
    \begin{tabular}{l|l}
    \toprule
        \textbf{Attributes / Methods} & \textbf{Description} \\
    \midrule
        Root & The root node of the tree. \\
    \midrule
        Traversal & Return nodes based on the order of operations.\\
        Get Cost & Aggregates the startup and total costs of all nodes.\\
    \bottomrule
    \end{tabular}
    \caption{Key Attributes and Methods for \textsc{ExecutionTree}}
    \label{tab:ExecutionTree_attributes}
\end{table}

The \textsc{Traversal} method uses post-order traversal methods to return nodes. $\textsc{Traversal}(o, \ell)$ means the current node is $o$, and the answer list is $\ell$. shown in Algorithm~\ref{algo:traversal}. The total cost and startup cost inside a tree is calculated by summing all the total cost and startup cost for each node in it.

\subsection{Interactive What-If Analysis}
\label{subsec:whatif-algo}

We explored generating alternative query plans by applying user-defined modifications to join and scan methods. \textsc{PrepareJoinCommand} and \textsc{PrepareScanCommand} generate \texttt{SET} commands to control PostgreSQL planner configurations. For instance, when a user selects \texttt{HASH\_JOIN}:
\begin{lstlisting}
SET enable_hashjoin = ON;
SET enable_mergejoin = OFF;
SET enable_nestloop = OFF;
\end{lstlisting}

\begin{algorithm}
	\caption{$\textsc{Traversal}(o, \ell)$}
    \label{algo:traversal}
	\begin{algorithmic}
        \For{$s\in\textsc{Son}(o)$}
            \State $\textsc{Traversal}(s, \ell)$
        \EndFor
        \State$\textsc{Append}(\ell, o)$
	\end{algorithmic} 
\end{algorithm}

This ensures that PostgreSQL uses only the specified join type when generating the QEP. Similarly, we can disables other scan methods and enables only index-based scanning by producing:

\begin{lstlisting}
SET enable_bitmapscan = OFF;
SET enable_indexscan = OFF;
SET enable_indexonlyscan = ON;
SET enable_seqscan = OFF;
\end{lstlisting}

\subsection{QEP Visualizer}

QEP Visualizer converts a \textsc{ExecutionTree} to a plot. Firstly,  We consider the tree as a planar graph and calculate the coordinates of each node using igraph~\cite{igraph}. The specific calculation method is mentioned in \cite{reingold1981tidier}. Then, Based on these coordinates, we perform scaling transformations to adapt them to the screen. Using Plotly~\cite{plotly}, we plot the nodes and edges in a Cartesian coordinate system. Finally, we remove the coordinate axes to generate an image of the tree.

To display information for each node concisely, we use symbols to represent each node, with the specific mappings listed in Table~\ref{tab:operation_description}. Detailed information about that node is displayed when the mouse hovers over a specific node.

\begin{table}[ht]
    \centering
    \begin{tabular}{c|c|l}
    \toprule
        \textbf{Operation} & \textbf{Symbol} & \textbf{Description} \\
    \midrule
        Aggregate & $\gamma$ & Performs aggregation operations like \texttt{SUM}, \texttt{AVG}, etc. \\
        Hash Join & $\Join_H$ & Joins two tables using a hash-based method. \\
        Merge Join & $\Join_M$ & Joins two sorted tables using a merge-based approach. \\
        Seq Scan & $\sigma$ & Sequentially scans all rows in a table. \\
        Index Scan & $\sigma_I$ & Scans rows using an index for faster lookup. \\
        Bitmap Heap Scan & $\sigma_B$ & Uses a bitmap index for efficient range scans. \\
        Sort & $\tau$ & Sorts the rows based on specified columns. \\
        Hash & $H$ & Creates a hash table for efficient data access. \\
        Gather Merge & $\gamma_M$ & Merges results from multiple parallel workers. \\
        Materialize & $M$ & Stores intermediate results in memory for reuse. \\
        Append & $\cup$ & Combines rows from multiple sources into one output. \\
        Unique & $\delta$ & Removes duplicate rows. \\
        Group & $\gamma$ & Groups rows by specific column(s) for aggregation. \\
        Window & $\omega$ & Computes window functions like \texttt{RANK}, \texttt{ROW\_NUMBER}, etc. \\
        Limit & $L$ & Restricts the output to a specified number of rows. \\
        Unknown Operation & $o$ & Represents an operation that is not recognized. \\
    \bottomrule
    \end{tabular}
    \caption{Operations and their corresponding symbols.}
    \label{tab:operation_description}
\end{table}


% \textbf{Flexibility for Various What-If Scenarios:}
% The code uses registries (\texttt{JOIN\_REGISTRY} and \texttt{SCAN\_REGISTRY}) to define supported join and scan types, making it easy to extend or customize. Users can combine different strategies for testing without modifying the core logic.

% \textbf{Core Steps in What-If Analysis:}
% \begin{enumerate}
%     \item \textbf{User Modifies the QEP}: Users interactively specify the desired join or scan type changes. The code translates these inputs into PostgreSQL configuration commands.
%     \item \textbf{Generate a New QEP}: The generated commands are executed, guiding PostgreSQL to produce a new Alternative Query Plan (AQP) reflecting the user’s modifications.
%     \item \textbf{Compare QEP and AQP}: By comparing the costs of the original QEP and the modified AQP, users can evaluate the impact of their changes on query performance.
% \end{enumerate}



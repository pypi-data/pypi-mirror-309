"""
    Cochl.Sense API

    Cochl.Sense API allows to detect what is contained inside sound data. Send audio data over the internet to discover what it contains.   # noqa: E501

    The version of the OpenAPI document: v1.7.10
    Contact: support@cochl.ai
    Generated by: https://openapi-generator.tech
"""


import re  # noqa: F401
import sys  # noqa: F401

from cochl_sense_api.api_client import ApiClient, Endpoint as _Endpoint
from cochl_sense_api.model_utils import (  # noqa: F401
    check_allowed_values,
    check_validations,
    date,
    datetime,
    file_type,
    none_type,
    validate_and_convert_types
)
from cochl_sense_api.model.audio_chunk import AudioChunk
from cochl_sense_api.model.create_session import CreateSession
from cochl_sense_api.model.created_session import CreatedSession
from cochl_sense_api.model.generic_error import GenericError
from cochl_sense_api.model.predict_request import PredictRequest
from cochl_sense_api.model.predict_response import PredictResponse
from cochl_sense_api.model.session_refs import SessionRefs
from cochl_sense_api.model.session_result import SessionResult
from cochl_sense_api.model.session_status import SessionStatus
from cochl_sense_api.model.update_session import UpdateSession


class AudioSessionApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client
        self.create_session_endpoint = _Endpoint(
            settings={
                'response_type': (CreatedSession,),
                'auth': [
                    'API_Key'
                ],
                'endpoint_path': '/audio_sessions/',
                'operation_id': 'create_session',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'create_session',
                ],
                'required': [
                    'create_session',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'create_session':
                        (CreateSession,),
                },
                'attribute_map': {
                },
                'location_map': {
                    'create_session': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.delete_session_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [],
                'endpoint_path': '/audio_sessions/{session_id}',
                'operation_id': 'delete_session',
                'http_method': 'DELETE',
                'servers': None,
            },
            params_map={
                'all': [
                    'session_id',
                ],
                'required': [
                    'session_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'session_id':
                        (str,),
                },
                'attribute_map': {
                    'session_id': 'session_id',
                },
                'location_map': {
                    'session_id': 'path',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.get_results_endpoint = _Endpoint(
            settings={
                'response_type': (SessionResult,),
                'auth': [],
                'endpoint_path': '/audio_sessions/{session_id}/results',
                'operation_id': 'get_results',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'session_id',
                    'offset',
                    'limit',
                ],
                'required': [
                    'session_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'offset',
                    'limit',
                ]
            },
            root_map={
                'validations': {
                    ('offset',): {

                        'inclusive_minimum': 0,
                    },
                    ('limit',): {

                        'inclusive_maximum': 1024,
                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'session_id':
                        (str,),
                    'offset':
                        (int,),
                    'limit':
                        (int,),
                },
                'attribute_map': {
                    'session_id': 'session_id',
                    'offset': 'offset',
                    'limit': 'limit',
                },
                'location_map': {
                    'session_id': 'path',
                    'offset': 'query',
                    'limit': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.predict_endpoint = _Endpoint(
            settings={
                'response_type': (PredictResponse,),
                'auth': [],
                'endpoint_path': '/audio_sessions/{session_id}/predict',
                'operation_id': 'predict',
                'http_method': 'POST',
                'servers': None,
            },
            params_map={
                'all': [
                    'session_id',
                    'predict_request',
                ],
                'required': [
                    'session_id',
                    'predict_request',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'session_id':
                        (str,),
                    'predict_request':
                        (PredictRequest,),
                },
                'attribute_map': {
                    'session_id': 'session_id',
                },
                'location_map': {
                    'session_id': 'path',
                    'predict_request': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.read_status_endpoint = _Endpoint(
            settings={
                'response_type': (SessionStatus,),
                'auth': [],
                'endpoint_path': '/audio_sessions/{session_id}/status',
                'operation_id': 'read_status',
                'http_method': 'GET',
                'servers': None,
            },
            params_map={
                'all': [
                    'session_id',
                    'offset',
                    'count',
                    'next_token',
                ],
                'required': [
                    'session_id',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                    'offset',
                    'count',
                ]
            },
            root_map={
                'validations': {
                    ('offset',): {

                        'inclusive_minimum': 0,
                    },
                    ('count',): {

                        'inclusive_maximum': 1024,
                        'inclusive_minimum': 1,
                    },
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'session_id':
                        (str,),
                    'offset':
                        (int,),
                    'count':
                        (int,),
                    'next_token':
                        (str,),
                },
                'attribute_map': {
                    'session_id': 'session_id',
                    'offset': 'offset',
                    'count': 'count',
                    'next_token': 'next_token',
                },
                'location_map': {
                    'session_id': 'path',
                    'offset': 'query',
                    'count': 'query',
                    'next_token': 'query',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [],
            },
            api_client=api_client
        )
        self.update_session_endpoint = _Endpoint(
            settings={
                'response_type': None,
                'auth': [],
                'endpoint_path': '/audio_sessions/{session_id}',
                'operation_id': 'update_session',
                'http_method': 'PATCH',
                'servers': None,
            },
            params_map={
                'all': [
                    'session_id',
                    'update_session',
                ],
                'required': [
                    'session_id',
                    'update_session',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'session_id':
                        (str,),
                    'update_session':
                        (UpdateSession,),
                },
                'attribute_map': {
                    'session_id': 'session_id',
                },
                'location_map': {
                    'session_id': 'path',
                    'update_session': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )
        self.upload_chunk_endpoint = _Endpoint(
            settings={
                'response_type': (SessionRefs,),
                'auth': [],
                'endpoint_path': '/audio_sessions/{session_id}/chunks/{chunk_sequence}',
                'operation_id': 'upload_chunk',
                'http_method': 'PUT',
                'servers': None,
            },
            params_map={
                'all': [
                    'session_id',
                    'chunk_sequence',
                    'audio_chunk',
                ],
                'required': [
                    'session_id',
                    'chunk_sequence',
                    'audio_chunk',
                ],
                'nullable': [
                ],
                'enum': [
                ],
                'validation': [
                ]
            },
            root_map={
                'validations': {
                },
                'allowed_values': {
                },
                'openapi_types': {
                    'session_id':
                        (str,),
                    'chunk_sequence':
                        (int,),
                    'audio_chunk':
                        (AudioChunk,),
                },
                'attribute_map': {
                    'session_id': 'session_id',
                    'chunk_sequence': 'chunk_sequence',
                },
                'location_map': {
                    'session_id': 'path',
                    'chunk_sequence': 'path',
                    'audio_chunk': 'body',
                },
                'collection_format_map': {
                }
            },
            headers_map={
                'accept': [
                    'application/json'
                ],
                'content_type': [
                    'application/json'
                ]
            },
            api_client=api_client
        )

    def create_session(
        self,
        create_session,
        **kwargs
    ):
        """Create Session  # noqa: E501

        Create a new session. An API key is required.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_session(create_session, async_req=True)
        >>> result = thread.get()

        Args:
            create_session (CreateSession):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            CreatedSession
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['create_session'] = \
            create_session
        return self.create_session_endpoint.call_with_http_info(**kwargs)

    def delete_session(
        self,
        session_id,
        **kwargs
    ):
        """Delete Session  # noqa: E501

        Change the state of the session to *deleted*. All future call on the session will return 404   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_session(session_id, async_req=True)
        >>> result = thread.get()

        Args:
            session_id (str): Session id represents a unique identifier for an audio session 

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['session_id'] = \
            session_id
        return self.delete_session_endpoint.call_with_http_info(**kwargs)

    def get_results(
        self,
        session_id,
        **kwargs
    ):
        """Get File Result  # noqa: E501

        Get state and result of File prediction.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_results(session_id, async_req=True)
        >>> result = thread.get()

        Args:
            session_id (str): Session id represents a unique identifier for an audio session 

        Keyword Args:
            offset (int): The number of result elements to skip in result pagination . [optional] if omitted the server will use the default value of 0
            limit (int): The maximum number of result elements in result pagination . [optional] if omitted the server will use the default value of 1024
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            SessionResult
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['session_id'] = \
            session_id
        return self.get_results_endpoint.call_with_http_info(**kwargs)

    def predict(
        self,
        session_id,
        predict_request,
        **kwargs
    ):
        """Predict  # noqa: E501

        Predict the given audio data   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.predict(session_id, predict_request, async_req=True)
        >>> result = thread.get()

        Args:
            session_id (str): Session id represents a unique identifier for an audio session 
            predict_request (PredictRequest): raw binary chunk 

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            PredictResponse
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['session_id'] = \
            session_id
        kwargs['predict_request'] = \
            predict_request
        return self.predict_endpoint.call_with_http_info(**kwargs)

    def read_status(
        self,
        session_id,
        **kwargs
    ):
        """Read Status  # noqa: E501

        Get session status  *Note that if all chunks didn't finish to be inferenced, the server will wait for at least one result to be  available in the required page range before returning result. Such waiting can lead to HTTP requests timeout. Therefore we recommend implementing a client retry logic.*   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.read_status(session_id, async_req=True)
        >>> result = thread.get()

        Args:
            session_id (str): Session id represents a unique identifier for an audio session 

        Keyword Args:
            offset (int): How many existing elements to skip before returning the first result control how many results to receive . [optional] if omitted the server will use the default value of 0
            count (int): Limit the length of the returned results array to limit the size of the returned payload . [optional] if omitted the server will use the default value of 1024
            next_token (str): The next token can be used from a previous page result. It allows to iterating through all the next elements of a collection. If next_token is set, offset and limit will be ignored . [optional]
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            SessionStatus
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['session_id'] = \
            session_id
        return self.read_status_endpoint.call_with_http_info(**kwargs)

    def update_session(
        self,
        session_id,
        update_session,
        **kwargs
    ):
        """Update Session  # noqa: E501

        (Deprecated) Update a session   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_session(session_id, update_session, async_req=True)
        >>> result = thread.get()

        Args:
            session_id (str): Session id represents a unique identifier for an audio session 
            update_session (UpdateSession):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            None
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['session_id'] = \
            session_id
        kwargs['update_session'] = \
            update_session
        return self.update_session_endpoint.call_with_http_info(**kwargs)

    def upload_chunk(
        self,
        session_id,
        chunk_sequence,
        audio_chunk,
        **kwargs
    ):
        """Upload Chunk  # noqa: E501

        Upload new audio chunk. This endpoint is only used by File Session.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.upload_chunk(session_id, chunk_sequence, audio_chunk, async_req=True)
        >>> result = thread.get()

        Args:
            session_id (str): Session id represents a unique identifier for an audio session 
            chunk_sequence (int): Chunk represents the chunk number. This is needed to be a counter starting from 0 and growing by one on each request 
            audio_chunk (AudioChunk):

        Keyword Args:
            _return_http_data_only (bool): response data without head status
                code and headers. Default is True.
            _preload_content (bool): if False, the urllib3.HTTPResponse object
                will be returned without reading/decoding response data.
                Default is True.
            _request_timeout (int/float/tuple): timeout setting for this request. If
                one number provided, it will be total request timeout. It can also
                be a pair (tuple) of (connection, read) timeouts.
                Default is None.
            _check_input_type (bool): specifies if type checking
                should be done one the data sent to the server.
                Default is True.
            _check_return_type (bool): specifies if type checking
                should be done one the data received from the server.
                Default is True.
            _host_index (int/None): specifies the index of the server
                that we want to use.
                Default is read from the configuration.
            async_req (bool): execute request asynchronously

        Returns:
            SessionRefs
                If the method is called asynchronously, returns the request
                thread.
        """
        kwargs['async_req'] = kwargs.get(
            'async_req', False
        )
        kwargs['_return_http_data_only'] = kwargs.get(
            '_return_http_data_only', True
        )
        kwargs['_preload_content'] = kwargs.get(
            '_preload_content', True
        )
        kwargs['_request_timeout'] = kwargs.get(
            '_request_timeout', None
        )
        kwargs['_check_input_type'] = kwargs.get(
            '_check_input_type', True
        )
        kwargs['_check_return_type'] = kwargs.get(
            '_check_return_type', True
        )
        kwargs['_host_index'] = kwargs.get('_host_index')
        kwargs['session_id'] = \
            session_id
        kwargs['chunk_sequence'] = \
            chunk_sequence
        kwargs['audio_chunk'] = \
            audio_chunk
        return self.upload_chunk_endpoint.call_with_http_info(**kwargs)


# AUTOGENERATED! DO NOT EDIT! File to edit: ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb.

# %% auto 0
__all__ = ['anova_oneway', 'draw_hist', 'test_normality_group', 'homogeneity_of_variance', 'auto_anova_for_df', 'draw_box',
           'auto_friedman_for_df', 'auto_kruskal_for_df']

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 64
import numpy as np
import pandas as pd

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 65
def anova_oneway(
    *groups: np.ndarray # 不同i的samples[i]表示不同的treatment下的实验数据。这里有个关键的地方，就是每一个group不要求有相同的长度，所以不是二维数据，而是一列不定长的np.array。
                 )->pd.DataFrame: # 返回ANOVA表格。包括我们课堂上学习的内容。
    if len(groups) < 2:
            raise TypeError('我们需要至少两个组才能进行ANOVA分析, 而'
                            f' 你给了我 {len(groups)} 个组.')
    means = [sum(group)/len(group) for group in groups]
    lengths_of_each_group = [len(group) for group in groups]
    
    # grand_mean = sum(means) / len(means) # 错误的公式
    # 正确公式1
    grand_mean = sum([mean*length for mean, length in zip(means, lengths_of_each_group)]) / sum(lengths_of_each_group)
    # 正确公式2
    flattened_samples = np.concatenate(groups)
    grand_mean_2 = flattened_samples.mean()
    assert np.isclose(grand_mean, grand_mean_2)

    # 平方和（Sum of Squares, SS）这个缩写课上其实没有讲，所以没听懂。
    # 计算组间平方和（Between SS）
    # between_ss = len(samples) * sum(mean**2 for mean in means)  # 错误的公式, 按照字面意义理解了 SS
    # 想算每一个group，如果把 grand mean 当做平均值， 把这个group的均值当做这个group所有人的值，那么这个group会有多大方差（没平均）。
    between_ss = sum([length * (mean - grand_mean)**2 for mean, length in zip(means, lengths_of_each_group)])
    
    # 计算组内平方和（Within SS）
    within_ss = sum(
        [
            (sum([(value-means[group_index])**2 for value in group]) # 每一个组自己求和
    ) for group_index, group in enumerate(groups) # 外层求和
        ]
    )

    # 计算总平方和（Total SS）
    # 但是我们实际上并不是算平方和啊，我们算的是和平均值差的平方和啊？这个取名。。。
    # ss_total = sum(sum(x**2 for x in sample) for sample in samples) # 错误的公式, 按照字面意义理解了 SS。
    # 正确公式1
    ss_total = sum(sum((x-grand_mean)**2 for x in group) for group in groups)
    
    # 正确公式2
    ss_total2 = between_ss + within_ss
    assert np.isclose(ss_total, ss_total2), f"{ss_total} vs {ss_total2}"
    
    # 课堂上其实没有讲，这里有一个重要的定理叫做 方差分解定理（law of total variance），
    # Var(X)=E[Var(X∣Y) ]+Var(E[X∣Y])
    

    
    # 计算自由度（df）
    df_between = len(groups) - 1
    df_within = sum([len(group) - 1 for group in groups]) # 注意这里是每一个 treatment 的自由度的和。
    
    # 计算均方（MS）
    ms_between = between_ss / df_between
    ms_within = within_ss / df_within
    
    # 计算F值
    f_value = ms_between / ms_within
    
    # 计算p值
    p_value_bigger_than_f = 1 - stats.f.cdf(f_value, dfn=df_between, dfd=df_within)
    p_value_excel = stats.f.pdf(f_value, dfn=df_between, dfd=df_within)
    # p_value = 1 - stats.f.cdf(f_value, dfn=df_within, dfd=df_between)
    
    # 创建ANOVA表格
    anova_table = {
        'Source': ['Between', 'Within', 'Total'],
        'Sum of Squares (SS)': [between_ss, within_ss, ss_total], # 拒绝缩写！我们要清晰地告诉用户这个是什么意思。
        'Degrees of Freedom (df)': [df_between, df_within, df_between + df_within], # 拒绝缩写
        'Mean Square (MS)': [ms_between, ms_within, None], # 拒绝缩写
        'F': [f_value, None, None],
        'p': [p_value_bigger_than_f, None, None],
        'p_excel': [p_value_excel, None, None]
    }
    return pd.DataFrame(anova_table)

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 77
import seaborn as sns

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 78
def draw_hist(df, chosen_cols, hue_col='群类别', transform = None, column_name_transform = None):
    if transform is None: transform = lambda x: x
    if column_name_transform is None: column_name_transform = lambda x: x
    fig, axs = plt.subplots(1, len(chosen_cols), figsize=(15, 5))  #
    for i, col in enumerate(chosen_cols):
        df[f"{col}_transformed_tmp"] = transform(df[col].to_numpy())
        # plt.hist(df['平均年龄'], bins=10, color='skyblue', edgecolor='black')  # 使用列名绘制直方图
        sns.histplot(data=df, x=f"{col}_transformed_tmp" , kde=True, ax=axs[i])
        axs[i].set_ylabel('频数')
        axs[i].set_xlabel(column_name_transform(col))
        
        # axs[i].grid(axis='y', alpha=0.75)
    fig, axs = plt.subplots(1, len(chosen_cols), figsize=(15, 5))  #
    for i, col in enumerate(chosen_cols):
        # plt.hist(df['平均年龄'], bins=10, color='skyblue', edgecolor='black')  # 使用列名绘制直方图
        sns.histplot(data=df, x=f"{col}_transformed_tmp" , kde=True, hue=hue_col, ax=axs[i])
        axs[i].set_ylabel('频数')
        axs[i].set_xlabel(column_name_transform(col))
        # 删除 f"{col}_transformed_tmp" 列
        del df[f"{col}_transformed_tmp"]

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 81
import numpy as np

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 82
def test_normality_group(df, interesting_col, hue_col='群类别', transform = None):
    if transform is None:
        transform = lambda x: x
    grouped_data = df.groupby(hue_col)
    # grouped_data
    normality_results = {}
    for name, group in grouped_data:
        normality_result = {}
        data_column = group[interesting_col].to_numpy()
        data_column = transform(data_column)
        res = stats.ks_1samp(data_column, stats.norm.cdf, alternative='two-sided')
        normality_result['Kolmogorov-Smirnov'] = "Not Normal" if res.pvalue < 0.05 else "Normal"
        res = stats.anderson(data_column, dist='norm')
        critical_value = res.critical_values[2] # 0.05 level
        normality_result['Anderson-Darling'] = "Not Normal" if res.statistic > critical_value else "Normal"
        res = stats.normaltest(data_column)
        normality_result["D'Agostino-Pearson"] = "Not Normal" if res.pvalue < 0.05 else "Normal"
        normality_results[name] = normality_result
    return pd.DataFrame(normality_results)

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 89
from scipy import stats

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 90
def homogeneity_of_variance(df, interesting_col, hue_col="群类别", transform=None):
    if transform is None:
        transform = lambda x: x
    new_col_name = f"{interesting_col}_transformed_tmp"
    df[new_col_name] = transform(df[interesting_col].to_numpy())
    interesting_col = new_col_name
    
    grouped_data = df.groupby(hue_col)

    std_devs = grouped_data[interesting_col].std()
    ratio_largest_to_smallest = std_devs.max() / std_devs.min() 
    variance_homogeneity = ratio_largest_to_smallest<= 2
    if not variance_homogeneity:
        print("The variances are not homogeneous!")
    else:
        print("The variances may be homogeneous, according to rule of thumb.")
    
    group_values_list = [grouped_data[interesting_col].get_group(x).values for x in grouped_data.groups]
    bartlett_result = stats.bartlett(*group_values_list)
    if bartlett_result.pvalue < 0.05:
        print("Reject the null hypothesis of equal variances! ")
        
    del df[new_col_name]

    return dict(
        ratio_largest_to_smallest=ratio_largest_to_smallest,
        bartlett_result=bartlett_result
    )

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 97
def auto_anova_for_df(df, interesting_col, hue_col="群类别", transform=None):
    if transform is None:
        transform = lambda x: x
    new_col_name = f"{interesting_col}_transformed_tmp"
    df[new_col_name] = transform(df[interesting_col].to_numpy())
    interesting_col = new_col_name
    grouped_data = df.groupby(hue_col)
    group_values_list = [grouped_data[interesting_col].get_group(x).values for x in grouped_data.groups]
    res = anova_oneway(*group_values_list)
    del df[new_col_name]
    return res

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 102
def draw_box(df, chosen_cols, hue_col='群类别', transform = None, column_name_transform = None):
    if transform is None: transform = lambda x: x
    if column_name_transform is None: column_name_transform = lambda x: x
    fig, axs = plt.subplots(1, len(chosen_cols), figsize=(15, 5))  #
    for i, col in enumerate(chosen_cols):
        df[f"{col}_transformed_tmp"] = transform(df[col].to_numpy())
        sns.boxplot(x=hue_col, y=f"{col}_transformed_tmp", data=df, ax=axs[i])
        axs[i].set_ylabel(column_name_transform(col))
        del df[f"{col}_transformed_tmp"]

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 105
from scipy import stats
def auto_friedman_for_df(df, interesting_col, hue_col="群类别", transform=None):
    if transform is None:
        transform = lambda x: x
    new_col_name = f"{interesting_col}_transformed_tmp"
    df[new_col_name] = transform(df[interesting_col].to_numpy())
    interesting_col = new_col_name
    grouped_data = df.groupby(hue_col)
    group_values_list = [grouped_data[interesting_col].get_group(x).values for x in grouped_data.groups]
    
    res = stats.friedmanchisquare(*group_values_list)
    
    del df[new_col_name]
    return res

# %% ../../notebooks/coding_projects/P1_ANOVA/anova.ipynb 108
from scipy import stats
def auto_kruskal_for_df(df, interesting_col, hue_col="群类别", transform=None):
    if transform is None:
        transform = lambda x: x
    new_col_name = f"{interesting_col}_transformed_tmp"
    df[new_col_name] = transform(df[interesting_col].to_numpy())
    interesting_col = new_col_name
    grouped_data = df.groupby(hue_col)
    group_values_list = [grouped_data[interesting_col].get_group(x).values for x in grouped_data.groups]
    
    res = stats.kruskal(*group_values_list)
    
    del df[new_col_name]
    return res

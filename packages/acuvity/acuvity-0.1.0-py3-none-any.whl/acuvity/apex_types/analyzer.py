# SPDX-License-Identifier: Apache-2.0
# 
# Copyright (C) 2024 Acuvity, Inc.
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# Code generated by regolithe-python. DO NOT EDIT.
# Source: github.com/acuvity/regolithe-python (templates/model.py.tmpl)

from .analyzermodel import AnalyzerModel
from .detector import Detector
from .elemental import ElementalModel
from pydantic import ConfigDict, Field
from typing import List, Optional


class Analyzer(ElementalModel):
    """
    Represents an analyzer.

    Attributes:
        id: ID is the identifier of the object.
        description: The description of the analyzer.
        detectors: The detectors the analyzer can use.
        enabled: Tell if the analyzer is enabled by default.
        group: The group the analyzer belongs to.
        models: The models used by the analyzer.
        name: The name of the analyzer.
        namespace: The namespace of the object.
        triggers: A list of trigger or globl pattern that the analyzer will react on. A trigger is the detector Group and Name separated with a /.
    """
    # there is a few things to know about elemental based models:
    # - they can never be strict
    # - we need to use enum values instead of their keys
    # - because of that we also need to use validate_default, otherwise the keys are used for enums on defaults
    # - we allow population by field name to make it more natural to use from python
    model_config = ConfigDict(
        strict=False,
        use_enum_values=True,
        validate_default=True,
        populate_by_name=True,
        extra="forbid",
    )

    # all spec fields
    id: Optional[str] = Field(
        None,
        alias="ID",
        description="ID is the identifier of the object.",
        frozen=True,
    )
    description: Optional[str] = Field(
        None,
        alias="description",
        description="The description of the analyzer.",
    )
    detectors: Optional[List[Detector]] = Field(
        None,
        alias="detectors",
        description="The detectors the analyzer can use.",
    )
    enabled: Optional[bool] = Field(
        None,
        alias="enabled",
        description="Tell if the analyzer is enabled by default.",
    )
    group: Optional[str] = Field(
        None,
        alias="group",
        description="The group the analyzer belongs to.",
    )
    models: Optional[List[AnalyzerModel]] = Field(
        None,
        alias="models",
        description="The models used by the analyzer.",
    )
    name: Optional[str] = Field(
        None,
        alias="name",
        description="The name of the analyzer.",
    )
    namespace: Optional[str] = Field(
        None,
        alias="namespace",
        description="The namespace of the object.",
        frozen=True,
    )
    triggers: Optional[List[str]] = Field(
        None,
        alias="triggers",
        description="A list of trigger or globl pattern that the analyzer will react on. A trigger is the detector Group and Name separated with a /.",
        examples=["Code/*"],
    )

    def model_dump(self, *args, **kwargs):
        # Overriding this method allows us to set defaults
        # which reflect the necessary settings when sending things to the APIs
        kwargs.setdefault('exclude_none', True)
        kwargs.setdefault('by_alias', True)
        return super().model_dump(*args, **kwargs)

    def model_dump_json(self, *args, **kwargs):
        # Overriding this method allows us to set defaults
        # which reflect the necessary settings when sending things to the APIs
        # without the need to explicitly call them out
        kwargs.setdefault('exclude_none', True)
        kwargs.setdefault('by_alias', True)
        return super().model_dump_json(*args, **kwargs)

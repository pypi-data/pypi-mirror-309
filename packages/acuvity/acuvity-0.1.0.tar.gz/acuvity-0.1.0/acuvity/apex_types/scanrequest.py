# SPDX-License-Identifier: Apache-2.0
# 
# Copyright (C) 2024 Acuvity, Inc.
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
#
# Code generated by regolithe-python. DO NOT EDIT.
# Source: github.com/acuvity/regolithe-python (templates/model.py.tmpl)

from .elemental import ElementalModel
from .extractionrequest import ExtractionRequest
from .scanexternaluser import ScanExternalUser
from enum import Enum
from pydantic import ConfigDict, Field, model_validator
from typing import Dict, List, Optional


class ScanRequestAnonymizationEnum(str, Enum):
    """
    ScanRequestAnonymizationEnum represents all the allowed values for the anonymization field in a ScanRequest.
    """
    FIXED_SIZE = "FixedSize"
    VARIABLE_SIZE = "VariableSize"


class ScanRequestTypeEnum(str, Enum):
    """
    ScanRequestTypeEnum represents all the allowed values for the type field in a ScanRequest.
    """
    INPUT = "Input"
    OUTPUT = "Output"


class ScanRequest(ElementalModel):
    """
    This is a scan request.

    Attributes:
        access_policy: AccessPolicy allows to pass optional Rego access policy. If not set, The action is always Allow, If it is set, it will be run, and the final decision will be computed based on that policy. If the rego code does not start with package main, then the needed classic package definition and  acuvity imports will be added automatically. If the code starts with package main, then everything remains untouched.
        analyzers: The name of the analyzers to run by the pipelines. If empty, it means all of them. Possible values are PIIs, Secrets, Topics, Confidentiality, Exploits.
        annotations: Annotations attached to the extraction.
        anonymization: How to anonymize the data. If deanonymize is true, then VariablSize is required.
        bypass_hash: In the case of a contentPolicy that asks for a confirmation, this is the hash you must send back to bypass the block. This is only useful when a content policy has been set.
        content_policy: ContentPolicy allows to pass optional Rego content policy. If not set, The action is always Allow, and there cannot be any alerts raised etc If it is set, it will be run, and the final decision will be computed based on that policy. If the rego code does not start with package main, then the needed classic package definition and  acuvity imports will be added automatically. If the code starts with package main, then everything remains untouched.
        extractions: The extractions to request.
        keywords: The keywords found during classification.
        messages: Messages to process and provide detections for. Use data in extractions for processing binary data.
        minimal_logging: If true, the system will not log the contents that were scanned.
        redactions: The redactions that has been performed.
        type: The type of text.
        user: The user information that the ScanRequest is passing on to the policy engine.
    """
    # there is a few things to know about elemental based models:
    # - they can never be strict
    # - we need to use enum values instead of their keys
    # - because of that we also need to use validate_default, otherwise the keys are used for enums on defaults
    # - we allow population by field name to make it more natural to use from python
    model_config = ConfigDict(
        strict=False,
        use_enum_values=True,
        validate_default=True,
        populate_by_name=True,
        extra="forbid",
    )

    # all spec fields
    access_policy: Optional[str] = Field(
        None,
        alias="accessPolicy",
        description="AccessPolicy allows to pass optional Rego access policy. If not set, The action is always Allow, If it is set, it will be run, and the final decision will be computed based on that policy. If the rego code does not start with package main, then the needed classic package definition and  acuvity imports will be added automatically. If the code starts with package main, then everything remains untouched.",
    )
    analyzers: Optional[List[str]] = Field(
        None,
        alias="analyzers",
        description="The name of the analyzers to run by the pipelines. If empty, it means all of them. Possible values are PIIs, Secrets, Topics, Confidentiality, Exploits.",
    )
    annotations: Optional[Dict[str, str]] = Field(
        None,
        alias="annotations",
        description="Annotations attached to the extraction.",
    )
    anonymization: Optional[ScanRequestAnonymizationEnum] = Field(
        ScanRequestAnonymizationEnum.FIXED_SIZE,
        alias="anonymization",
        description="How to anonymize the data. If deanonymize is true, then VariablSize is required.",
    )
    bypass_hash: Optional[str] = Field(
        None,
        alias="bypassHash",
        description="In the case of a contentPolicy that asks for a confirmation, this is the hash you must send back to bypass the block. This is only useful when a content policy has been set.",
        examples=["Alice"],
    )
    content_policy: Optional[str] = Field(
        None,
        alias="contentPolicy",
        description="ContentPolicy allows to pass optional Rego content policy. If not set, The action is always Allow, and there cannot be any alerts raised etc If it is set, it will be run, and the final decision will be computed based on that policy. If the rego code does not start with package main, then the needed classic package definition and  acuvity imports will be added automatically. If the code starts with package main, then everything remains untouched.",
    )
    extractions: Optional[List[ExtractionRequest]] = Field(
        None,
        alias="extractions",
        description="The extractions to request.",
    )
    keywords: Optional[List[str]] = Field(
        None,
        alias="keywords",
        description="The keywords found during classification.",
    )
    messages: Optional[List[str]] = Field(
        None,
        alias="messages",
        description="Messages to process and provide detections for. Use data in extractions for processing binary data.",
    )
    minimal_logging: Optional[bool] = Field(
        None,
        alias="minimalLogging",
        description="If true, the system will not log the contents that were scanned.",
    )
    redactions: Optional[List[str]] = Field(
        None,
        alias="redactions",
        description="The redactions that has been performed.",
    )
    type: Optional[ScanRequestTypeEnum] = Field(
        None,
        alias="type",
        description="The type of text.",
    )
    user: Optional[ScanExternalUser] = Field(
        None,
        alias="user",
        description="The user information that the ScanRequest is passing on to the policy engine.",
    )

    # additional validation methods for the model
    @model_validator(mode='after')
    def __additional_model_validation(self) -> 'ScanRequest':
        ap = self.access_policy
        cp = self.content_policy

        # redactions and content_policy are mutually exclusive
        red = self.redactions
        if red is not None and len(red) > 0 and cp is not None and cp != "":
            raise ValueError("if redactions are set, you cannot use content_policy and vice versa")

        # keywords and access policy are mutually exclusive
        kw = self.keywords
        if kw is not None and len(kw) > 0 and ap is not None and ap != "":
            raise ValueError("if keywords are set, you cannot use access_policy and vice versa")

        # analyzers and access policy are mutually exclusive
        an = self.analyzers
        if an is not None and len(an) > 0 and ap is not None and ap != "":
            raise ValueError("if analyzers are set, you cannot use access_policy and vice versa")

        return self

    def model_dump(self, *args, **kwargs):
        # Overriding this method allows us to set defaults
        # which reflect the necessary settings when sending things to the APIs
        kwargs.setdefault('exclude_none', True)
        kwargs.setdefault('by_alias', True)
        return super().model_dump(*args, **kwargs)

    def model_dump_json(self, *args, **kwargs):
        # Overriding this method allows us to set defaults
        # which reflect the necessary settings when sending things to the APIs
        # without the need to explicitly call them out
        kwargs.setdefault('exclude_none', True)
        kwargs.setdefault('by_alias', True)
        return super().model_dump_json(*args, **kwargs)

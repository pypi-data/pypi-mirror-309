import numpy as np
from scipy.ndimage import binary_fill_holes

from saenopy.pyTFM.calculate_stress_imports.mask_interpolation import mask_interpolation
from saenopy.pyTFM.calculate_stress_imports.grid_setup_solids_py import prepare_forces
from saenopy.pyTFM.calculate_stress_imports.grid_setup_solids_py import grid_setup
from saenopy.pyTFM.calculate_stress_imports.grid_setup_solids_py import FEM_simulation
from saenopy.pyTFM.calculate_stress_imports.find_borders import find_borders

from saenopy.pyTFM.calculate_stress_imports.stress_functions import line_tension
from saenopy.pyTFM.calculate_stress_imports.stress_functions import all_stress_measures
from saenopy.pyTFM.calculate_stress_imports.stress_functions import (
    coefficient_of_variation,
)
from saenopy.pyTFM.calculate_stress_imports.stress_functions import (
    mean_stress_vector_norm,
)


def calculate_stress(mask, pixel_size, shape, u, tx, ty):
    res_dict = {}

    ps1 = pixel_size  # pixel size of the image of the beads
    # dimensions of the image of the beads
    ps2 = ps1 * np.mean(
        np.array(shape) / np.array(u.shape)
    )  # pixel size of the deformation field

    # first mask: The area used for Finite Elements Methods
    # it should encircle all forces generated by the cell colony
    mask_fem = binary_fill_holes(
        mask == 1
    )  # the mask should be a single patch without holes
    # changing the masks dimensions to fit to the deformation and traction field:
    mask_fem = mask_interpolation(mask_fem, dims=tx.shape)

    # second mask: The area of the cells. Average stresses and other values are calculated only
    # on the actual area of the cell, represented by this mask.
    mask_cells_full = binary_fill_holes(mask == 2)
    mask_cells = mask_interpolation(mask_cells_full, dims=tx.shape)

    # converting traction forces (forces per surface area) to actual forces
    # and correcting imbalanced forces and torques
    # tx->traction forces in x direction, ty->traction forces in y direction
    # ps2->pixel size of the traction field, mask_FEM-> mask for FEM
    fx, fy = prepare_forces(tx, ty, ps2, mask_fem)

    # constructing the FEM grid
    nodes, elements, loads, mats = grid_setup(mask_fem, -fx, -fy, sigma=0.5)
    # performing the FEM analysis
    # verbose prints the progress of numerically solving the FEM system of equations.
    ug_sol, stress_tensor = FEM_simulation(
        nodes, elements, loads, mats, mask_fem, verbose=True
    )
    stress_tensor = np.nan_to_num(stress_tensor)
    # UG_sol is a list of deformations for each node. We don't need it here.

    # analyzing the FEM results with average stresses
    sigma_max, sigma_min, sigma_max_abs, tau_max, phi_n, phi_shear, sigma_mean = (
        all_stress_measures(stress_tensor, px_size=ps2 * 10**-6)
    )
    mask_int = mask_interpolation(
        mask_cells_full, dims=sigma_mean.shape, min_cell_size=100
    )
    res_dict["mean normal stress Cell Area"] = np.mean(np.abs(sigma_mean[mask_int]))
    res_dict["max normal stress Cell Area"] = np.mean(np.abs(sigma_max_abs[mask_int]))
    res_dict["max shear stress Cell Area"] = np.mean(np.abs(tau_max[mask_int]))
    res_dict["cv mean normal stress Cell Area"] = coefficient_of_variation(
        mask_int, sigma_mean, 0
    )
    res_dict["cv max normal stress Cell Area"] = coefficient_of_variation(
        mask_int, sigma_max_abs, 0
    )
    res_dict["cv max shear stress Cell Area"] = coefficient_of_variation(
        mask_int, tau_max, 0
    )

    # mean normal stress
    ms_map = ((stress_tensor[:, :, 0, 0] + stress_tensor[:, :, 1, 1]) / 2) / (
        ps2 * 10**-6
    )
    # average on the area of the cell colony.
    ms = np.mean(ms_map[mask_cells])  # 0.0043 N/m

    # coefficient of variation
    cv = np.nanstd(ms_map[mask_cells]) / np.abs(
        np.nanmean(ms_map[mask_cells])
    )  # 0.41 no unit

    """ Calculating the Line Tension """
    # identifying borders, counting cells, performing spline interpolation to smooth the borders
    borders = find_borders(mask == 2, tx.shape)
    # we can for example get the number of cells from the "borders" object
    n_cells = borders.n_cells  # 8
    res_dict["cell number"] = n_cells
    res_dict["area Cell Area"] = np.sum(mask == 2) * ((pixel_size * 10**-6) ** 2)

    # calculating the line tension along the cell borders
    lt, min_v, max_v = line_tension(
        borders.lines_splines, borders.line_lengths, stress_tensor, pixel_length=ps2
    )
    # lt is a nested dictionary. The first key is the id of a cell border.
    # For each cell border the line tension vectors ("t_vecs"), the normal
    # and shear component of the line tension ("t_shear") and the normal
    # vectors of the cell border ("n_vecs") are calculated at a large number of points.

    # average norm of the line tension. Only borders not at colony edge are used
    lt_vecs = np.concatenate(
        [lt[l_id]["t_vecs"] for l_id in lt.keys() if l_id not in borders.edge_lines]
    )

    res_dict["average magnitude line tension"] = np.mean(
        np.linalg.norm(lt_vecs, axis=1)
    )
    res_dict["std magnitude line tension"] = np.std(np.linalg.norm(lt_vecs, axis=1))

    # average normal component of the line tension
    lt_normal = np.concatenate(
        [lt[l_id]["t_normal"] for l_id in lt.keys() if l_id not in borders.edge_lines]
    )

    # here you can see that almost the line tensions act almost exclusively perpendicular to the cell borders.
    res_dict["average normal line tension"] = np.mean(np.abs(lt_normal))
    res_dict["std normal line tension"] = np.std(np.abs(lt_normal))

    # average normal component of the line tension
    lt_shear = np.concatenate(
        [lt[l_id]["t_shear"] for l_id in lt.keys() if l_id not in borders.edge_lines]
    )
    res_dict["average shear line tension"] = np.mean(np.abs(lt_shear))
    res_dict["std shear line tension"] = np.std(np.abs(lt_shear))

    # plotting the line tension

    # norm of the line tension vector
    line_tension_norm = mean_stress_vector_norm(
        lt, borders, norm_level="points", vtype="t_vecs", exclude_colony_edge=True
    )
    res_dict["average magnitude line tension"] = line_tension_norm[1]
    res_dict["std magnitude line tension"] = line_tension_norm[2]

    # normal component of the line tension vector
    line_tension_n = mean_stress_vector_norm(
        lt, borders, norm_level="points", vtype="t_normal", exclude_colony_edge=True
    )
    res_dict["average normal line tension"] = line_tension_n[1]
    res_dict["std normal line tension"] = line_tension_n[2]

    # shear component of the line tension vector
    line_tension_sh = mean_stress_vector_norm(
        lt, borders, norm_level="points", vtype="t_shear", exclude_colony_edge=True
    )
    res_dict["average shear line tension"] = line_tension_sh[1]
    res_dict["std shear line tension"] = line_tension_sh[2]

    avg_cell_force = mean_stress_vector_norm(
        lt, borders, norm_level="cells", vtype="t_vecs", exclude_colony_edge=True
    )
    res_dict["average cell force"] = avg_cell_force[1]
    res_dict["std cell force"] = avg_cell_force[2]

    avg_cell_pressure = mean_stress_vector_norm(
        lt, borders, norm_level="cells", vtype="t_normal", exclude_colony_edge=True
    )
    res_dict["average cell pressure"] = avg_cell_pressure[1]
    res_dict["std cell pressure"] = avg_cell_pressure[2]

    avg_cell_shear = mean_stress_vector_norm(
        lt, borders, norm_level="cells", vtype="t_shear", exclude_colony_edge=True
    )
    res_dict["average cell shear"] = avg_cell_shear[1]
    res_dict["std cell shear"] = avg_cell_shear[2]

    attributes = dict(
        fx=fx,
        fy=fy,
        ms=ms,
        cv=cv,
        borders_edge_lines=borders.edge_lines,
        borders_inter_shape=borders.inter_shape,
        lt=lt,
        min_v=min_v,
        max_v=max_v,
    )

    return res_dict, attributes

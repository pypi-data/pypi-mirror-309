
import sys
from os.path import dirname
from inspect import getfullargspec

import bpy

# add the utils directory to sys.path
sys.path.append(dirname(__file__))

from blender_utils.blender_context_manager import mesh_edit  # noqa
from blender_utils.blender_file_loader import parse_args  # noqa
from blender_utils.blender_remesh_opt import separate_chaos_vertices, flatten_bumpy_vertices  # noqa

param = parse_args()


def remesh(mode: str,
           octree_depth: int = 8,
           use_smooth_shade: bool = True,
           use_remove_disconnected: bool = False,
           voxel_size: float = 0.15,
           adaptivity: float = 0.1,):
    """Apply blender remesh modifier. And resolve the bumpy surface if needed.

    Args:
        mode (str): Represent the remesh model name: ('BLOCKS', 'SMOOTH', 'SHARP', 'VOXEL')

                    Blocks: There is no smoothing at all.

                    Smooth: Output a smooth surface.

                    Sharp: Similar to Smooth, but preserves sharp edges and corners.

                    Sharpness: Higher values produce edges more similar to the input, 
                    while lower values filter out noise.

                    Voxel: Uses an OpenVDB to generate a new manifold mesh from the 
                    current geometry while trying to preserve the mesh's original volume.

        octree_depth (int): Represent the octree depth value.

        use_smooth_shade (bool): Represent the flag of applying smooth shade.

        use_remove_disconnected (bool): Represent the flag of removing disconnected vertices.



    """
    # Add remesh modifier to the import mesh object
    modifier = bpy.data.objects[param.mesh_name].modifiers.new(
        name="Remesh", type='REMESH')
    modifier.mode = mode

    if mode == 'SMOOTH':    # Smooth mode
        modifier.octree_depth = octree_depth
        modifier.use_remove_disconnected = use_remove_disconnected
    elif mode == 'VOXEL':   # Voxel mode
        modifier.voxel_size = voxel_size
        modifier.adaptivity = adaptivity

    modifier.use_smooth_shade = use_smooth_shade
    bpy.ops.object.modifier_apply(modifier="Remesh")


def flatten_vertices(max_linked_face_num: int,
                     max_bumpy_height: float,
                     iterations: int):
    """Represent the flag of resolving bumpy surface. The bumpy surface are normally generated by 
    remesh modifier. It could be better for fixing the surface along with Octree depth:9

        max_linked_face_num (int): Represent the max number of linked faces of the bumpy vertex.
        (i.e. doc/images/blender/blender_surface_remesh_002.png)

        max_bumpy_height (float): Represent the max height of the bumpy vertex.
        (i.g. doc/images/blender/blender_surface_remesh_004.png)

        iterations (int): Represent the iteration number of resolving the bumpy surface.
    """
    # Add smooth modifier to the import mesh object
    print(f'Remesh - fix the bumpy surface: {param.mesh_name}')

    # remove chaos vertices (multiple surfaces share the same vertex)
    for i in range(iterations):
        with mesh_edit(mesh_name=param.mesh_name) as bm:

            separate_chaos_vertices(
                bm, is_selected_only=False, max_linked_face_num=max_linked_face_num)

            bpy.ops.mesh.select_all(action="SELECT")
            bpy.ops.mesh.quads_convert_to_tris(
                quad_method='BEAUTY', ngon_method='BEAUTY')
            bpy.ops.mesh.select_all(action="DESELECT")

    with mesh_edit(mesh_name=param.mesh_name) as bm:
        for i in range(3, 6):
            verts = [v for v in bm.verts if v.select !=
                     True and len(v.link_edges) == i]
            flatten_bumpy_vertices(
                bm, verts=verts, max_distance_threshold=max_bumpy_height)


def triangulate(ngon_method: str, quad_method: str, keep_custom_normals: bool):
    """
    Triangulate the mesh with the given parameters.
    """
    # Add triangulate modifier to the import mesh object
    modifier = bpy.data.objects[param.mesh_name].modifiers.new(
        name="Triangulate", type='TRIANGULATE')
    modifier.keep_custom_normals = keep_custom_normals
    modifier.ngon_method = ngon_method
    modifier.quad_method = quad_method
    bpy.ops.object.modifier_apply(modifier="Triangulate")


def smooth(factor: float, iterations: int):
    """
    Smooth the mesh with the given parameters.
    """
    # Add smooth modifier to the import mesh object
    modifier = bpy.data.objects[param.mesh_name].modifiers.new(
        name="Smooth", type="SMOOTH")
    modifier.factor = factor
    modifier.iterations = iterations
    bpy.ops.object.modifier_apply(modifier="Smooth")


def corrective_smooth(smooth_type: str, factor: float, iterations: int, use_only_smooth: bool):
    """
    Smooth the mesh with the given parameters.
    """
    # Add smooth modifier to the import mesh object
    modifier = bpy.data.objects[param.mesh_name].modifiers.new(
        name="CorrectiveSmooth", type="CORRECTIVE_SMOOTH")
    modifier.smooth_type = smooth_type
    modifier.factor = factor
    modifier.iterations = iterations
    modifier.use_only_smooth = use_only_smooth
    bpy.ops.object.modifier_apply(modifier="CorrectiveSmooth")


def decimate(ratio: float, use_collapse_triangulate: bool, decimate_type: str):
    """
    Decimate the mesh with the given parameters.
    """
    # Add smooth modifier to the import mesh object
    modifier = bpy.data.objects[param.mesh_name].modifiers.new(
        name="Decimate", type="DECIMATE")
    modifier.ratio = ratio
    modifier.use_collapse_triangulate = use_collapse_triangulate
    modifier.decimate_type = decimate_type
    bpy.ops.object.modifier_apply(modifier="Decimate")


MODIFIERS = {
    'remesh': remesh,
    'flatten_vertices': flatten_vertices,
    'triangulate': triangulate,
    'smooth': smooth,
    'corrective_smooth': corrective_smooth,
    'decimate': decimate
}

BOOLEAN_IDENTIFIERS = ['True', 'False']


def resolve_method_call(args: tuple):
    args_dict = dict(map(lambda x: x.split('='), args))
    # parse func name from args, and resolve the function
    func_name = args_dict.pop('name')
    func = MODIFIERS.get(func_name)

    param_type = getfullargspec(func).annotations
    modifier_param = {key: param_type[key](
        v) if v not in BOOLEAN_IDENTIFIERS else v == 'True' for key, v in args_dict.items()}
    print(f'Apply modifier {func.__name__} with args {modifier_param}')
    func(**modifier_param)


for modifier_param_str in param.argv:
    modifier_param = modifier_param_str.split(',')
    resolve_method_call(tuple(modifier_param))


param.export()
